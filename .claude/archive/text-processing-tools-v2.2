# Text Processing Tools Implementation Guide

## Overview
This document outlines the implementation of 5 essential text processing tools for the Nomad Navigator travel planning application. These tools will enhance data quality, improve AI accuracy, and provide better monitoring capabilities.

## Tool Implementations

### 1. date-fns (Date Parsing & Formatting)

**Purpose:** Parse and format dates from natural language user input for travel planning.

**Installation:**
```bash
npm install date-fns
```

**Key Use Cases:**
- Parse "mid-January", "December 15th", "next week" into structured dates
- Format dates consistently for AI prompts
- Handle date validation and edge cases

**Implementation in Project:**

**Location:** `src/lib/utils/date-parser.ts`
```typescript
import { parse, format, isValid, addDays, startOfMonth } from 'date-fns';

export class TravelDateParser {
  static parseFlexibleDate(input: string): Date | null {
    // Handle relative dates like "next week", "mid-January"
    const normalized = input.toLowerCase().trim();
    
    if (normalized.includes('next week')) {
      return addDays(new Date(), 7);
    }
    
    if (normalized.includes('mid-') && normalized.includes('january')) {
      const year = new Date().getFullYear();
      return new Date(year, 0, 15); // January 15th
    }
    
    // Try standard date parsing
    const parsedDate = parse(input, 'MMMM do', new Date());
    return isValid(parsedDate) ? parsedDate : null;
  }
  
  static formatForAI(date: Date): string {
    return format(date, 'yyyy-MM-dd');
  }
}
```

**Integration Points:**
- Update `src/ai/flows/analyze-initial-prompt.ts` to use date parsing
- Enhance `src/ai/flows/generate-personalized-itinerary.ts` date handling
- Add to `destination-parser.ts` for comprehensive input processing

### 2. validator.js (Input Validation & Sanitization)

**Purpose:** Clean and validate user inputs before AI processing to prevent errors and improve data quality.

**Installation:**
```bash
npm install validator
npm install @types/validator
```

**Key Use Cases:**
- Sanitize text inputs to remove harmful characters
- Validate email formats for user accounts
- Check and clean destination names
- Normalize input formats

**Implementation in Project:**

**Location:** `src/lib/utils/input-validator.ts`
```typescript
import validator from 'validator';

export class TravelInputValidator {
  static sanitizeDestination(input: string): string {
    // Remove special characters but keep spaces, hyphens, apostrophes
    return validator.whitelist(input, 'a-zA-Z0-9 \'-');
  }
  
  static validateEmail(email: string): boolean {
    return validator.isEmail(email);
  }
  
  static sanitizeTravelInput(input: string): string {
    // Escape HTML, trim whitespace, normalize
    const escaped = validator.escape(input);
    const trimmed = validator.trim(escaped);
    return validator.normalizeEmail(trimmed) || trimmed;
  }
  
  static validateBudget(budget: string): number | null {
    const cleaned = budget.replace(/[^0-9.]/g, '');
    return validator.isFloat(cleaned) ? parseFloat(cleaned) : null;
  }
}
```

**Integration Points:**
- Add validation to `src/components/itinerary-form.tsx`
- Integrate with `destination-parser.ts`
- Use in all AI flow input processing
- Add to chat input in `chat-display.tsx`

### 3. Winston (Structured Logging)

**Purpose:** Monitor AI performance, track API usage, and debug issues across the application.

**Installation:**
```bash
npm install winston
```

**Key Use Cases:**
- Log AI response times and quality
- Track API usage across Google, Amadeus, weather services
- Monitor errors and performance issues
- Debug when tests pass but UI fails

**Implementation in Project:**

**Location:** `src/lib/utils/logger.ts`
```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

export class TravelLogger {
  static logAIRequest(flowName: string, input: any, startTime: number) {
    logger.info('AI Request', {
      flow: flowName,
      inputLength: JSON.stringify(input).length,
      timestamp: new Date().toISOString()
    });
  }
  
  static logAIResponse(flowName: string, responseTime: number, success: boolean) {
    logger.info('AI Response', {
      flow: flowName,
      responseTime,
      success,
      timestamp: new Date().toISOString()
    });
  }
  
  static logAPICall(apiName: string, endpoint: string, responseTime: number) {
    logger.info('API Call', {
      api: apiName,
      endpoint,
      responseTime,
      timestamp: new Date().toISOString()
    });
  }
}
```

**Integration Points:**
- Add logging to all AI flows in `src/ai/flows/`
- Monitor API calls in `src/lib/api/`
- Track user interactions in components
- Integrate with your existing AI testing script

### 4. spaCy Integration (Advanced NLP)

**Purpose:** Enhanced entity extraction for better understanding of travel requests.

**Note:** Since your project is TypeScript/Node.js, we'll use a Python microservice approach or JavaScript NLP alternatives.

**Alternative JavaScript Implementation:**
```bash
npm install compromise
```

**Location:** `src/lib/utils/nlp-parser.ts`
```typescript
import nlp from 'compromise';

export class AdvancedTravelParser {
  static extractEntities(text: string) {
    const doc = nlp(text);
    
    return {
      places: doc.places().out('array'),
      dates: doc.dates().out('array'),
      numbers: doc.values().out('array'),
      duration: this.extractDuration(text),
      travelers: this.extractTravelerCount(text)
    };
  }
  
  private static extractDuration(text: string): string | null {
    const durationPatterns = [
      /(\d+)\s*(day|days|week|weeks|month|months)/gi,
      /(weekend|long weekend)/gi
    ];
    
    for (const pattern of durationPatterns) {
      const match = text.match(pattern);
      if (match) return match[0];
    }
    return null;
  }
  
  private static extractTravelerCount(text: string): number {
    const doc = nlp(text);
    const numbers = doc.values().out('array');
    
    // Look for patterns like "2 people", "family of 4"
    if (text.includes('family')) return 4; // default family size
    if (text.includes('couple')) return 2;
    
    return numbers.length > 0 ? parseInt(numbers[0]) : 1;
  }
}
```

**Integration Points:**
- Enhance `destination-parser.ts` with advanced entity extraction
- Use in `analyze-initial-prompt.ts` for better input understanding
- Add to form validation in components

### 5. cheerio (Web Scraping - Optional)

**Purpose:** Extract additional travel data when APIs are unavailable or for data enrichment.

**Installation:**
```bash
npm install cheerio
npm install @types/cheerio
```

**Key Use Cases:**
- Backup data when APIs hit rate limits
- Gather additional destination information
- Extract travel tips from travel websites
- Get real-time attraction hours when not available via API

**Implementation in Project:**

**Location:** `src/lib/utils/web-scraper.ts`
```typescript
import cheerio from 'cheerio';

export class TravelDataScraper {
  static async getDestinationInfo(destination: string): Promise<any> {
    try {
      // Example: Scrape basic destination info (respect robots.txt and rate limits)
      const response = await fetch(`https://example-travel-site.com/search?q=${destination}`);
      const html = await response.text();
      const $ = cheerio.load(html);
      
      return {
        description: $('.destination-description').first().text(),
        highlights: $('.highlight-item').map((i, el) => $(el).text()).get(),
        tips: $('.travel-tip').map((i, el) => $(el).text()).get()
      };
    } catch (error) {
      console.error('Scraping failed:', error);
      return null;
    }
  }
  
  static async getAttractionHours(attractionName: string): Promise<string | null> {
    // Implement scraping for attraction hours as fallback
    // Always respect robots.txt and implement proper delays
    return null;
  }
}
```

**Important Notes:**
- Always check robots.txt before scraping
- Implement rate limiting and delays
- Use as fallback only when APIs fail
- Respect website terms of service

## Implementation Timeline

### Week 1: Foundation
1. Install and configure Winston logging
2. Implement validator.js for input sanitization
3. Add date-fns for date parsing

### Week 2: Enhancement
4. Integrate compromise/NLP parsing
5. Update existing destination-parser.ts
6. Add logging to AI flows

### Week 3: Optimization
7. Implement cheerio scraping (if needed)
8. Add comprehensive error handling
9. Update AI testing script to use new tools

## Integration with Existing Code

### Update destination-parser.ts:
```typescript
import { TravelDateParser } from '../utils/date-parser';
import { TravelInputValidator } from '../utils/input-validator';
import { AdvancedTravelParser } from '../utils/nlp-parser';

export function enhancedDestinationParser(input: string) {
  // Sanitize input first
  const cleanInput = TravelInputValidator.sanitizeTravelInput(input);
  
  // Extract entities
  const entities = AdvancedTravelParser.extractEntities(cleanInput);
  
  // Parse dates
  const dates = entities.dates.map(date => TravelDateParser.parseFlexibleDate(date));
  
  // Return structured data
  return {
    destinations: entities.places,
    dates: dates.filter(Boolean),
    duration: entities.duration,
    travelers: entities.travelers,
    originalInput: input,
    cleanedInput: cleanInput
  };
}
```

### Add to AI Flows:
```typescript
import { TravelLogger } from '../utils/logger';

export async function generatePersonalizedItinerary(input: any) {
  const startTime = Date.now();
  TravelLogger.logAIRequest('generateItinerary', input, startTime);
  
  try {
    // Your existing AI logic
    const result = await ai.generate(prompt);
    
    TravelLogger.logAIResponse('generateItinerary', Date.now() - startTime, true);
    return result;
  } catch (error) {
    TravelLogger.logAIResponse('generateItinerary', Date.now() - startTime, false);
    throw error;
  }
}
```

## Monitoring and Maintenance

### Log Analysis:
- Monitor `logs/combined.log` for performance trends
- Set up alerts for high error rates
- Track API usage patterns

### Performance Tracking:
- Use Winston logs to identify slow AI flows
- Monitor date parsing accuracy
- Track input validation effectiveness

### Testing Integration:
- Add new tools to your AI testing script
- Test edge cases with various input formats
- Validate logging and monitoring functionality

This implementation will significantly improve your travel app's data quality, monitoring capabilities, and user experience while maintaining the existing architecture and patterns.
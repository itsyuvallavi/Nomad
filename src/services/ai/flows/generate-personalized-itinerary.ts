// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {z} from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/services/ai/schemas';
// AI parser removed - using conversational approach
import { logger } from '@/lib/monitoring/logger';
// Import conversational generator
import { generateConversationalItinerary } from '@/services/ai/utils/conversational-generator';

// Stub functions for legacy code paths
function validateTripComplexity(_prompt: string) {
  return {
    valid: true,
    complexity: 'standard',
    estimatedDuration: 5000,
    error: null as any
  };
}

function generateUnifiedItinerary(prompt: string, _attachedFile?: string, _additionalContext?: any) {
  // Redirect to conversational generator
  return generateConversationalItinerary(prompt, '');
}

function generateConversationalItineraryWrapper(prompt: string) {
  return generateConversationalItinerary(prompt, '');
}

function getUnifiedGenerator() {
  return {
    isConfigured: true,
    getMetrics: () => ({
      tokensUsed: 1000,
      processingTime: 5000,
      complexity: 'standard'
    })
  };
}
import { enrichItineraryWithOSM } from '@/services/ai/services/location-enrichment-osm';
import { getWeatherForecast } from '@/services/api/weather';
import { logAIRequest, logAIResponse, logAIError } from '@/lib/monitoring/ai-logger';
import { logItinerary, logUserAction, logPerformance, logError } from '@/lib/monitoring/production-logger';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  const startTime = Date.now();
  
  // Log user action for production monitoring
  logUserAction('itinerary_generation_start', {
    prompt_length: input.prompt.length,
    has_conversation_history: !!input.conversationHistory,
    has_attachment: !!input.attachedFile
  });

  // Log the incoming request
  const requestId = await logAIRequest(input.prompt, {
    model: 'gpt-4o-mini',
    strategy: 'ultra-fast'
  });
  
  // Combine prompt with conversation history for better context
  let actualPrompt = input.prompt;
  if (input.conversationHistory) {
    // Include full conversation history for AI parser to understand context
    actualPrompt = input.conversationHistory + '\n' + input.prompt;
  }
  
  // Log to browser console if in client-side environment
  if (typeof window !== 'undefined') {
    console.group('üöÄ Generate Personalized Itinerary');
    console.log('üìù Initial prompt:', input.prompt);
    console.log('üí¨ Actual prompt from history:', actualPrompt);
    console.log('üìé Has attachment:', !!input.attachedFile);
    console.log('üí¨ Has conversation history:', !!input.conversationHistory);
    console.groupEnd();
  }
  
  // ‚ö†Ô∏è CRITICAL: NEVER USE MOCK DATA!
  // ‚úÖ ALL data MUST come from OpenAI API
  // ‚ùå NO hardcoded itineraries allowed
  // ‚ùå NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '‚ùå CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  const generator = getUnifiedGenerator();
  if (!generator.isConfigured) {
    logger.error('SYSTEM', 'OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  // First validate trip complexity
  const validation = validateTripComplexity(actualPrompt);
  if (!validation.valid) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è Validation check:', validation.error);
    }
    // Log as info, not error, since this is expected user input validation
    logger.info('AI', 'Trip validation - needs more info', { reason: validation.error });
    
    // Make the error message more user-friendly for the UI
    const userFriendlyError = validation.error?.includes('multiple continents') || 
                              validation.error?.includes('too many destinations') ||
                              validation.error?.includes('too long') ||
                              validation.error?.includes('too complex')
      ? "Your search is too complex for our beta version. Try a simpler trip with fewer destinations!"
      : validation.error;
    
    // Return a special response for validation errors instead of throwing
    return {
      destination: 'Input Validation',
      title: 'More Information Needed',
      itinerary: [],
      quickTips: [
        "Try planning a trip with fewer destinations (maximum 5 cities)",
        "Consider shorter trips (maximum 30 days total)",
        "Focus on one region or continent for better planning"
      ],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: userFriendlyError || "Please provide more details about your trip"
    } as any;
  }
  
  // ONLY use AI-powered parsing - no fallbacks to regex
  let parsedTrip;
  
  try {
    // COMMENTED OUT: This is redundant - enhanced-generator-ultra-fast.ts already does this!
    // parsedTrip = await parseDestinationsWithAI(actualPrompt);
    
    // Skip the redundant parsing to avoid double API calls
    parsedTrip = { origin: '', destinations: [], totalDays: 0 };
    logger.info('AI', 'ü§ñ AI parser results', {
      origin: parsedTrip.origin,
      destinations: parsedTrip.destinations.length,
      totalDays: parsedTrip.totalDays
    });
  } catch (error: any) {
    logger.error('AI', 'AI parser failed', error);
    // Return error to user instead of falling back
    return {
      destination: 'Parser Error',
      title: 'Unable to Parse Trip',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: `I couldn't understand your trip request. Please try rephrasing it. Error: ${error.message}`
    } as any;
  }
  
  // Origin is completely optional now - we don't need it for trip planning
  let origin = parsedTrip.origin || '';
  
  // SKIP this validation - the ultra-fast generator will parse destinations internally
  // This validation was causing false errors after we removed the redundant parsing
  /*
  if (!parsedTrip.destinations || parsedTrip.destinations.length === 0) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è No destinations found - throwing error for UI popup');
    }
    logger.info('AI', 'No destinations found - throwing error for UI');
    
    return {
      destination: 'Input Validation',
      title: 'Destination Required',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: `I couldn't understand your destination. Please specify where you'd like to travel, like "3 days in London" or "Weekend trip to Paris"`
    } as any;
  }
  */
  
  // If origin is missing, just log it but continue - it's not required
  if (!origin || origin === '') {
    logger.info('AI', 'Origin not provided - this is fine, we can plan without it');
    origin = ''; // Keep it empty, no placeholder needed
  }
  
  // Update parsedTrip with the found origin
  parsedTrip.origin = origin;
  
  if (typeof window !== 'undefined') {
    console.log('‚úÖ Trip complexity validated');
    console.log('‚úàÔ∏è Origin detected:', parsedTrip.origin);
  }
  logger.info('AI', 'Trip complexity validated - proceeding with generation');
  
  // Use enhanced generator if we have the APIs configured
  const hasLocationIQ = !!process.env.LOCATIONIQ_API_KEY || !!process.env.NEXT_PUBLIC_LOCATIONIQ_API_KEY;
  const hasWeatherAPI = !!process.env.OPENWEATHERMAP;
  const useEnhanced = hasLocationIQ || hasWeatherAPI;
  
  if (useEnhanced) {
    if (typeof window !== 'undefined') {
      console.log('üéØ Using ENHANCED generation with APIs:', {
        LocationIQ: hasLocationIQ,
        Weather: hasWeatherAPI
      });
    }

    logger.info('AI', 'Using ENHANCED generation with multiple APIs', {
      hasLocationIQ: hasLocationIQ,
      hasWeather: hasWeatherAPI
    });
    
    try {
      // Use conversational approach for better UX
      const result = await generateConversationalItineraryWrapper(
        actualPrompt
      );
      
      if (typeof window !== 'undefined') {
        console.log('‚ö° Ultra-fast generation successful');
      }
      logger.info('AI', 'Ultra-fast generation successful');
      
      // Enrich with LocationIQ data if available
      if (hasLocationIQ) {
        logger.info('AI', 'Enriching ultra-fast itinerary with LocationIQ data');
        try {
          const enrichedResult = await enrichItineraryWithOSM(result, {
            useOSM: true,
            optimizeRoutes: true
          });
          logger.info('AI', 'LocationIQ enrichment successful for ultra-fast');
          
          // Add weather data if available
          let finalResult = enrichedResult;
          if (hasWeatherAPI && enrichedResult.destination && enrichedResult.itinerary) {
            try {
              logger.info('AI', 'Fetching weather data for enriched itinerary');
              const weatherData = await getWeatherForecast(
                enrichedResult.destination,
                enrichedResult.itinerary.length
              );

              if (weatherData && weatherData.length > 0) {
                finalResult.itinerary = finalResult.itinerary.map((day: any, index: number) => {
                  const dayWeather = weatherData[index];
                  if (dayWeather) {
                    return {
                      ...day,
                      weather: {
                        temp: dayWeather.temp,
                        weather: dayWeather.weather,
                        humidity: dayWeather.humidity,
                        wind_speed: dayWeather.wind_speed,
                        pop: dayWeather.pop
                      }
                    };
                  }
                  return day;
                });
                logger.info('AI', 'Weather data added to enriched itinerary');
              }
            } catch (weatherError) {
              logger.warn('AI', 'Weather fetch failed for enriched itinerary', weatherError);
            }
          }

          // Log successful response with enrichment
          await logAIResponse(requestId, finalResult, {
            model: 'gpt-4o-mini',
            strategy: 'ultra-fast-enriched',
            destinations: [finalResult.destination],
            totalDays: finalResult.itinerary?.length || 0
          });

          // Log production metrics for successful generation
          const duration = Date.now() - startTime;
          logItinerary({
            id: requestId,
            input: {
              prompt: input.prompt,
              model: 'gpt-4o-mini',
              strategy: 'ultra-fast-enriched'
            },
            output: {
              destinations: enrichedResult.destination,
              days: enrichedResult.itinerary?.length || 0,
              activities: enrichedResult.itinerary?.reduce((sum, day) => sum + (day.activities?.length || 0), 0) || 0,
              title: enrichedResult.title || enrichedResult.destination,
              duration: `${duration}ms`,
              success: true
            },
            performance: {
              totalDuration: duration,
              apiCalls: 1,
              cacheHit: false
            }
          });
          
          logUserAction('itinerary_generation_success', {
            duration_ms: duration,
            destinations: enrichedResult.destination,
            days: enrichedResult.itinerary?.length || 0,
            strategy: 'ultra-fast-enriched'
          });
          
          return enrichedResult as GeneratePersonalizedItineraryOutput;
        } catch (enrichError: any) {
          logger.warn('AI', 'LocationIQ enrichment failed for ultra-fast, using non-enriched result', { error: enrichError.message });
          // Fall back to non-enriched result
          await logAIResponse(requestId, result, {
            model: 'gpt-4o-mini',
            strategy: 'ultra-fast',
            destinations: [result.destination],
            totalDays: result.itinerary?.length || 0
          });
          
          return result;
        }
      } else {
        // Log successful response
        await logAIResponse(requestId, result, {
          model: 'gpt-4o-mini',
          strategy: 'ultra-fast',
          destinations: [result.destination],
          totalDays: result.itinerary?.length || 0
        });
        
        // Log production metrics for successful generation
        const duration = Date.now() - startTime;
        logItinerary({
          id: requestId,
          input: {
            prompt: input.prompt,
            model: 'gpt-4o-mini',
            strategy: 'ultra-fast'
          },
          output: {
            destinations: result.destination,
            days: result.itinerary?.length || 0,
            activities: result.itinerary?.reduce((sum: number, day: any) => sum + (day.activities?.length || 0), 0) || 0,
            title: result.title || result.destination,
            duration: `${duration}ms`,
            success: true
          },
          performance: {
            totalDuration: duration,
            apiCalls: 1,
            cacheHit: false
          }
        });
        
        logUserAction('itinerary_generation_success', {
          duration_ms: duration,
          destinations: result.destination,
          days: result.itinerary?.length || 0,
          strategy: 'ultra-fast'
        });
        
        return result;
      }
    } catch (error: any) {
      if (typeof window !== 'undefined') {
        console.warn('‚ö†Ô∏è Enhanced generation failed, falling back:', error.message);
      }
      logger.error('AI', 'Enhanced generation failed, falling back to standard', { error: error.message });
      
      // Log the error
      await logAIError(requestId, error, {
        model: 'gpt-4o-mini',
        strategy: 'ultra-fast'
      });
      
      // Log production metrics for failed generation
      const duration = Date.now() - startTime;
      logItinerary({
        id: requestId,
        input: {
          prompt: input.prompt,
          model: 'gpt-4o-mini',
          strategy: 'ultra-fast'
        },
        error: {
          message: error.message,
          stack: error.stack,
          code: error.code
        },
        performance: {
          totalDuration: duration,
          apiCalls: 1,
          cacheHit: false
        }
      });
      
      logUserAction('itinerary_generation_error', {
        duration_ms: duration,
        error_message: error.message,
        strategy: 'ultra-fast'
      });
      
      // Fall through to standard generation
    }
  }
  
  // Fallback to unified generation
  if (typeof window !== 'undefined') {
    console.log('ü§ñ Using unified OpenAI generation');
  }
  logger.info('AI', 'Using unified OpenAI generation');
  
  try {
    const result = await generateUnifiedItinerary(
      actualPrompt,
      input.attachedFile,
      input.conversationHistory
    );
    
    logger.info('AI', 'Unified OpenAI generation successful');
    
    // Log performance metrics
    const metrics = generator.getMetrics();
    logger.info('AI', 'Generation metrics', metrics);
    
    // Enrich with LocationIQ data if available
    if (hasLocationIQ) {
      logger.info('AI', 'Enriching itinerary with LocationIQ data');
      try {
        const enrichedResult = await enrichItineraryWithOSM(result, {
          useOSM: true,
          optimizeRoutes: true
        });
        logger.info('AI', 'LocationIQ enrichment successful');
        
        // Log successful response from unified generator with enrichment
        await logAIResponse(requestId, enrichedResult, {
          model: 'gpt-4o-mini',
          strategy: 'unified-enriched',
          destinations: [enrichedResult.destination],
          totalDays: enrichedResult.itinerary?.length || 0
        });
        
        return enrichedResult as GeneratePersonalizedItineraryOutput;
      } catch (enrichError: any) {
        logger.warn('AI', 'LocationIQ enrichment failed, using non-enriched result', { error: enrichError.message });
        // Fall back to non-enriched result
        await logAIResponse(requestId, result, {
          model: 'gpt-4o-mini',
          strategy: 'unified',
          destinations: [result.destination],
          totalDays: result.itinerary?.length || 0
        });
        
        return result;
      }
    } else {
      // Log successful response from unified generator
      await logAIResponse(requestId, result, {
        model: 'gpt-4o-mini',
        strategy: 'unified',
        destinations: [result.destination],
        totalDays: result.itinerary?.length || 0
      });
      
      return result;
    }
  } catch (error: any) {
    logger.error('AI', 'Unified generation failed', { error: error.message, stack: error.stack });
    
    // Log the final error
    await logAIError(requestId, error, {
      model: 'gpt-4o-mini',
      strategy: 'unified'
    });
    
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

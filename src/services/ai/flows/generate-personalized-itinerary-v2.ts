/**
 * Generate Personalized Itinerary V2
 * True conversational flow - NO DEFAULTS EVER
 */

'use server';

import { z } from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/services/ai/schemas';
import { logger } from '@/lib/monitoring/logger';
import {
  AIConversationController,
  ConversationResponse,
  ResponseType
} from '@/services/ai/conversation/ai-conversation-controller';
import { generateConversationalItinerary } from '@/services/ai/utils/conversational-generator';
import { enrichItineraryWithOSM } from '@/services/ai/services/location-enrichment-osm';
import { getWeatherForecast } from '@/services/api/weather';
import { logAIRequest, logAIResponse, logAIError } from '@/lib/monitoring/ai-logger';
import { logUserAction, logPerformance } from '@/lib/monitoring/production-logger';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z.string().describe('User message'),
  attachedFile: z.string().optional(),
  conversationHistory: z.string().optional().describe("Serialized conversation context"),
  sessionId: z.string().optional().describe("Session ID for conversation continuity"),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export interface ConversationalItineraryOutput {
  type: 'question' | 'confirmation' | 'itinerary' | 'error';
  message: string;
  awaitingInput?: string;
  suggestedOptions?: string[];
  itinerary?: GeneratePersonalizedItineraryOutput;
  conversationContext?: string; // Serialized context for next call
  requiresGeneration?: boolean;
}

/**
 * Main entry point for conversational itinerary generation
 * NEVER uses defaults - always asks for missing information
 */
export async function generatePersonalizedItineraryV2(
  input: GeneratePersonalizedItineraryInput
): Promise<ConversationalItineraryOutput> {
  const startTime = Date.now();

  // Log user action
  logUserAction('itinerary_generation_v2_start', {
    prompt_length: input.prompt.length,
    has_context: !!input.conversationHistory,
    session_id: input.sessionId
  });

  try {
    // Initialize or restore AI conversation controller
    const controller = new AIConversationController(
      input.sessionId,
      input.conversationHistory
    );

    // Process the user message
    const response: ConversationResponse = await controller.processMessage(input.prompt);

    // Log the conversation step
    logger.info('AI', 'Conversation step', {
      type: response.type,
      state: response.type,
      awaitingInput: response.awaitingInput
    });

    // Handle different response types
    switch (response.type) {
      case ResponseType.QUESTION:
        // Return question to gather more information
        return {
          type: 'question',
          message: response.message,
          awaitingInput: response.awaitingInput,
          conversationContext: controller.getContext()
        };

      case ResponseType.CONFIRMATION:
        // Ask for confirmation before generating
        return {
          type: 'confirmation',
          message: response.message,
          awaitingInput: 'confirmation',
          conversationContext: controller.getContext()
        };

      case ResponseType.ITINERARY:
        // Itinerary has been generated by the AI controller
        if (response.itinerary) {
          // Log performance
          logPerformance('itinerary_generation_v2', Date.now() - startTime, {
            hasItinerary: true,
            sessionId: input.sessionId
          });

          return {
            type: 'itinerary',
            message: response.message,
            itinerary: response.itinerary,
            conversationContext: controller.getContext()
          };
        }

        // Shouldn't happen but handle gracefully
        return {
          type: 'error',
          message: 'Something went wrong generating your itinerary. Please try again.',
          conversationContext: controller.getContext()
        };

      // Removed MODIFICATION case - not part of new ResponseType enum

      case ResponseType.ERROR:
      default:
        return {
          type: 'error',
          message: response.message || 'Something went wrong. Let me help you plan your trip - where would you like to go?',
          conversationContext: controller.getContext()
        };
    }
  } catch (error: any) {
    logger.error('AI', 'Conversation controller error', error);

    // Return a helpful error message that restarts the conversation
    return {
      type: 'question',
      message: "I'm having trouble understanding. Let's start fresh - where would you like to travel?",
      awaitingInput: 'destination',
      conversationContext: undefined // Reset context on error
    };
  }
}

/**
 * Check if we can generate with current context
 * Used by UI to determine if generate button should be enabled
 */
export async function canGenerateItinerary(
  conversationContext?: string
): Promise<boolean> {
  if (!conversationContext) return false;

  try {
    const controller = new AIConversationController(undefined, conversationContext);
    return controller.canGenerate();
  } catch {
    return false;
  }
}
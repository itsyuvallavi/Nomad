
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { GeneratePersonalizedItineraryOutputSchema } from '@/ai/schemas';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { findAccommodation, findRestaurants, findWorkspaces, findAttractions } from '@/lib/api/foursquare';
import { getWeatherForecast, getWeatherSummary } from '@/lib/api/weather';
import { validateAPIKeys, logAPIKeyStatus } from '@/lib/api-validation';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  return generatePersonalizedItineraryFlow(input);
}

const estimateFlightTime = ai.defineTool(
  {
    name: 'estimateFlightTime',
    description: 'Estimates flight time between two cities. Use this for adding flight information to the itinerary.',
    inputSchema: z.object({
      origin: z.string().describe('Origin city (e.g., "London", "New York")'),
      destination: z.string().describe('Destination city (e.g., "Paris", "Tokyo")'),
    }),
    outputSchema: z.object({
      duration: z.string().describe('Estimated flight duration'),
      departureAirport: z.string().describe('Main airport in origin city'),
      arrivalAirport: z.string().describe('Main airport in destination city'),
    }),
  },
  async (input) => {
    console.log('\n‚úàÔ∏è [Flight Tool] CALLED by AI model');
    console.log('‚úàÔ∏è [Flight Tool] Estimating flight:', input.origin, '‚Üí', input.destination);
    
    // Common flight routes with approximate times
    const routes: Record<string, Record<string, {duration: string, airports: [string, string]}>> = {
      'london': {
        'paris': { duration: '1h 15min', airports: ['London Heathrow (LHR)', 'Paris Charles de Gaulle (CDG)'] },
        'lisbon': { duration: '2h 45min', airports: ['London Heathrow (LHR)', 'Lisbon Airport (LIS)'] },
        'barcelona': { duration: '2h 15min', airports: ['London Gatwick (LGW)', 'Barcelona El Prat (BCN)'] },
        'rome': { duration: '2h 30min', airports: ['London Heathrow (LHR)', 'Rome Fiumicino (FCO)'] },
        'amsterdam': { duration: '1h 20min', airports: ['London City (LCY)', 'Amsterdam Schiphol (AMS)'] },
        'new york': { duration: '7h 30min', airports: ['London Heathrow (LHR)', 'JFK International (JFK)'] },
      },
      'new york': {
        'los angeles': { duration: '5h 30min', airports: ['JFK International (JFK)', 'LAX International (LAX)'] },
        'london': { duration: '7h 00min', airports: ['JFK International (JFK)', 'London Heathrow (LHR)'] },
        'paris': { duration: '8h 00min', airports: ['JFK International (JFK)', 'Paris Charles de Gaulle (CDG)'] },
        'miami': { duration: '3h 00min', airports: ['LaGuardia (LGA)', 'Miami International (MIA)'] },
      },
      'paris': {
        'london': { duration: '1h 15min', airports: ['Paris Charles de Gaulle (CDG)', 'London Heathrow (LHR)'] },
        'rome': { duration: '2h 00min', airports: ['Paris Orly (ORY)', 'Rome Fiumicino (FCO)'] },
        'barcelona': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Barcelona El Prat (BCN)'] },
        'lisbon': { duration: '2h 30min', airports: ['Paris Orly (ORY)', 'Lisbon Airport (LIS)'] },
        'amsterdam': { duration: '1h 10min', airports: ['Paris Charles de Gaulle (CDG)', 'Amsterdam Schiphol (AMS)'] },
        'berlin': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Berlin Brandenburg (BER)'] },
      },
      'lisbon': {
        'london': { duration: '2h 45min', airports: ['Lisbon Airport (LIS)', 'London Heathrow (LHR)'] },
        'paris': { duration: '2h 30min', airports: ['Lisbon Airport (LIS)', 'Paris Orly (ORY)'] },
        'madrid': { duration: '1h 20min', airports: ['Lisbon Airport (LIS)', 'Madrid Barajas (MAD)'] },
        'barcelona': { duration: '1h 50min', airports: ['Lisbon Airport (LIS)', 'Barcelona El Prat (BCN)'] },
      },
      'tokyo': {
        'london': { duration: '12h 30min', airports: ['Narita International (NRT)', 'London Heathrow (LHR)'] },
        'new york': { duration: '14h 00min', airports: ['Narita International (NRT)', 'JFK International (JFK)'] },
        'singapore': { duration: '7h 00min', airports: ['Narita International (NRT)', 'Singapore Changi (SIN)'] },
        'seoul': { duration: '2h 30min', airports: ['Narita International (NRT)', 'Incheon International (ICN)'] },
      },
    };
    
    const originLower = input.origin.toLowerCase();
    const destLower = input.destination.toLowerCase();
    
    // Check if we have this route
    if (routes[originLower]?.[destLower]) {
      const route = routes[originLower][destLower];
      console.log('‚úÖ [Flight Tool] Found route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[0],
        arrivalAirport: route.airports[1],
      };
    }
    
    // Check reverse route
    if (routes[destLower]?.[originLower]) {
      const route = routes[destLower][originLower];
      console.log('‚úÖ [Flight Tool] Found reverse route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[1],
        arrivalAirport: route.airports[0],
      };
    }
    
    // Default estimate based on distance
    console.log('‚ö†Ô∏è [Flight Tool] Route not in database, using estimate');
    return {
      duration: '3h 00min (estimated)',
      departureAirport: `${input.origin} International Airport`,
      arrivalAirport: `${input.destination} International Airport`,
    };
  }
);

const getWeatherForecastTool = ai.defineTool(
    {
        name: 'getWeatherForecast',
        description: 'MANDATORY: Gets the real weather forecast for a specific location. Call this FIRST before planning activities.',
        inputSchema: z.object({
            location: z.string().describe('The city name (e.g., "Lisbon", "Paris", "Tokyo").'),
        }),
        outputSchema: z.object({
            forecast: z.string().describe('Weather summary for the location.'),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        const apiKey = process.env.OPENWEATHERMAP;
        if (!apiKey || apiKey.length < 20) {
            console.warn('‚ö†Ô∏è [Weather Tool] API key is missing or invalid.');
            return { 
                forecast: "Weather: Typical seasonal conditions expected (API key not configured)", 
                success: false 
            };
        }
        console.log('\nüîî [Weather Tool] CALLED by AI model');
        console.log('üå§Ô∏è [Weather Tool] Getting weather for:', input.location);
        try {
            const weatherData = await getWeatherForecast(input.location, 5);
            if (weatherData && weatherData.length > 0) {
                const summary = weatherData.slice(0, 3)
                    .map(w => `${w.date}: ${w.weather.main}, ${w.temp.min}-${w.temp.max}¬∞C`)
                    .join('; ');
                console.log('‚úÖ [Weather Tool] SUCCESS - Got real weather data from OpenWeatherMap API');
                console.log('   üìä Weather summary:', summary);
                return { forecast: summary, success: true };
            }
        } catch (error) {
            console.error('‚ùå [Weather Tool] API error:', error);
        }
        return { forecast: "Weather: Moderate temperatures expected", success: false };
    }
);

const findRealPlacesTool = ai.defineTool(
    {
        name: 'findRealPlaces',
        description: 'MANDATORY: Finds REAL places in a destination. You MUST use this for EVERY place in the itinerary.',
        inputSchema: z.object({
            destination: z.string().describe('The city to search (e.g., "Lisbon", "Paris", "Tokyo").'),
            placeType: z.enum(['accommodation', 'restaurant', 'workspace', 'attraction']).describe('Type of place to find.'),
            limit: z.number().optional().default(5).describe('Number of results (default: 5).'),
        }),
        outputSchema: z.object({
            places: z.array(z.object({
                name: z.string(),
                address: z.string(),
                category: z.string().optional(),
                rating: z.number().optional(),
            })),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        if (!process.env.FOURSQUARE_API_KEY) {
            console.error('‚ùå [Places Tool] API key is missing. Please set FOURSQUARE_API_KEY in your .env file.');
            return { 
                places: [{
                    name: `Could not search for ${input.placeType}`,
                    address: `Foursquare API key is missing.`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
        console.log('\nüîî [Places Tool] CALLED by AI model');
        console.log('üîç [Places Tool] Searching for', input.placeType, 'in', input.destination);
        console.log('üìç [Places Tool] Request details:', JSON.stringify(input));
        
        try {
            let places: any[] = [];
            const searchLimit = input.limit || 5;
            
            switch (input.placeType) {
                case 'accommodation':
                    places = await findAccommodation(input.destination);
                    break;
                case 'restaurant':
                    places = await findRestaurants(input.destination, undefined, searchLimit);
                    break;
                case 'workspace':
                    places = await findWorkspaces(input.destination, searchLimit);
                    break;
                case 'attraction':
                    places = await findAttractions(input.destination, searchLimit);
                    break;
            }
            
            // Found real places from Foursquare
            
            if (places.length === 0) {
                // No places found, using defaults
                // Return some default places as fallback
                return {
                    places: [{
                        name: `${input.placeType} in ${input.destination}`,
                        address: `${input.destination} city center`,
                        category: input.placeType,
                        rating: 4.0
                    }],
                    success: false
                };
            }
            
            const result = {
                places: places.slice(0, searchLimit).map(p => ({
                    name: p.name || `${input.placeType} venue`,
                    address: p.location?.formatted_address || `${input.destination} area`,
                    category: p.categories?.[0]?.name || input.placeType,
                    rating: p.rating || undefined,
                })),
                success: true
            };
            
            // Returning places
            
            return result;
        } catch (error) {
            console.error('‚ùå [Places Tool] API error:', error);
            return { 
                places: [{
                    name: `${input.placeType} in ${input.destination}`,
                    address: `${input.destination} city center`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
    }
);


const prompt = ai.definePrompt({
  name: 'generatePersonalizedItineraryPrompt',
  input: {schema: GeneratePersonalizedItineraryInputSchema},
  output: {schema: GeneratePersonalizedItineraryOutputSchema},
  tools: [estimateFlightTime, getWeatherForecastTool, findRealPlacesTool],
  config: {
    temperature: 0.7,
    maxOutputTokens: 8192,
  },
  prompt: `You are a master travel agent specializing in creating personalized itineraries for nomad travelers. Your response must be a detailed day-by-day itinerary in a structured JSON format.

  **CRITICAL DATE HANDLING:**
  Today's date is: ${new Date().toISOString().split('T')[0]}
  Current year: ${new Date().getFullYear()}
  
  1. Extract the EXACT dates from the user's prompt.
  2. ALWAYS use the CURRENT YEAR (${new Date().getFullYear()}) unless the user specifies a different year.
  3. If user says "January 15-20", use ${new Date().getFullYear()}-01-15 to ${new Date().getFullYear()}-01-20.
  4. If user says "5 days starting March 1st", calculate dates starting ${new Date().getFullYear()}-03-01.
  5. If user says "next week", calculate from today's date: ${new Date().toISOString().split('T')[0]}.
  6. ALWAYS use YYYY-MM-DD format for dates.
  7. The number of days in the itinerary array MUST EXACTLY match the requested trip duration.

  Analyze the user's request to extract:
  - Trip duration and EXACT dates (very important!)
  - Destination(s) 
  - Origin/departure location (CRITICAL for flight information)
  - Any specific preferences mentioned
  
  User's request: {{{prompt}}}
  {{#if conversationHistory}}
  Conversation History: {{{conversationHistory}}}
  {{/if}}

  **SMART DEFAULTS TO USE (unless user specifies otherwise):**
  - **Budget:** Moderate budget of $150-200 per day per person.
  - **Accommodation:** Mid-range hotels or quality Airbnbs.
  - **Activities:** Mix of popular tourist highlights, local cultural experiences, and food.
  - **Travel Style:** Balanced comfort and adventure (2-3 main activities per day).
  - **Meals:** Mix of local restaurants.

  **MANDATORY TOOL USAGE - YOU MUST FOLLOW THIS EXACTLY:**
  
  STEP 1: Call estimateFlightTime tool.
  
  STEP 2: Call getWeatherForecast tool.
  
  STEP 3: Call findRealPlaces for accommodation. Pick ONE real hotel from the results.
  
  STEP 4: For EACH day, call findRealPlaces multiple times for restaurants, attractions, etc.
  
  **FLIGHT INFORMATION (MANDATORY):**
  - DAY 1 FIRST ACTIVITY: Must be the departure flight.
  - LAST DAY LAST ACTIVITY: Must be the return flight.
  
  **CRITICAL RULES:**
  1. NEVER make up place names - ONLY use results from the findRealPlaces tool.
  2. Each place in your itinerary MUST come from a tool call (except flights).
  3. Include the ACTUAL address returned by the API.
  4. Your itinerary MUST contain real places with real addresses.
  5. ALWAYS include departure and return flights.
  6. Extract and use the origin location from the user's prompt for flight information.

  {{#if attachedFile}}
  The user has also attached a file for reference. Use this to inform the itinerary.
  Attached file: {{media url=attachedFile}}
  {{/if}}

  **FINAL OUTPUT REQUIREMENTS:**
  You MUST return a valid JSON object with ALL of these fields:
  - destination: string (the city/location)
  - title: string (a catchy trip title)
  - itinerary: array of day objects, each with:
    - day: number
    - date: string in YYYY-MM-DD format using year ${new Date().getFullYear()}
    - title: string
    - activities: array with time, description, category, address fields
  - quickTips: array of 3-5 string tips
  
  NEVER return null or undefined. Always return a complete JSON structure. The itinerary array must have exactly the number of days matching the trip duration.
  `,
});

const generatePersonalizedItineraryFlow = ai.defineFlow(
  {
    name: 'generatePersonalizedItineraryFlow',
    inputSchema: GeneratePersonalizedItineraryInputSchema,
    outputSchema: GeneratePersonalizedItineraryOutputSchema,
  },
  async (input) => {
    // Validate API keys at the start
    const apiKeys = validateAPIKeys();
    logAPIKeyStatus(apiKeys);
    
    if (!apiKeys.gemini.isValid) {
      throw new Error('AI service is not configured. Please ensure GEMINI_API_KEY is set in your .env file.');
    }
    
    try {
      const {output, usage} = await prompt(input);

      if (!output || output === null) {
        console.error('‚ùå AI returned null or undefined');
        throw new Error('AI model returned null - retrying with fallback');
      }
      
      if (output.itinerary && Array.isArray(output.itinerary)) {
        console.log(`‚úÖ Generated itinerary for ${output.destination}: ${output.itinerary.length} days`);
      }
      
      if (!output.destination || !output.title) {
        throw new Error('Invalid itinerary structure - missing required fields');
      }
      
      if (!output.itinerary || !Array.isArray(output.itinerary) || output.itinerary.length === 0) {
        throw new Error('Invalid itinerary structure - empty or invalid itinerary array');
      }
      
      for (const day of output.itinerary) {
        if (!day.date || !day.activities || day.activities.length === 0) {
          throw new Error(`Invalid day ${day.day} - missing date or activities`);
        }
      }
      
      // Generation complete
      return output;
    } catch (error) {
      console.error('[ITINERARY GENERATION] Error:', error);
      
      // Include error details in the response for client-side debugging
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('[ITINERARY GENERATION] Error details:', errorMessage);
      
      const today = new Date();
      const dates = Array.from({ length: 3 }, (_, i) => {
        const date = new Date(today);
        date.setDate(date.getDate() + i);
        return date.toISOString().split('T')[0];
      });
      
      return {
        destination: 'Your Destination',
        title: 'Trip Itinerary - Error: ' + errorMessage,
        itinerary: [{
          day: 1,
          date: dates[0],
          title: 'Day 1 - API Error',
          activities: [{
            time: 'Morning',
            description: 'We\'re having trouble connecting to our travel APIs. Please check your API keys and try again.',
            category: 'Travel' as const,
            address: 'Location pending'
          }]
        }],
        quickTips: [
          'Ensure you have a stable internet connection',
          'Check that your Foursquare and OpenWeatherMap API keys are in your .env file',
          'Try specifying a major city as your destination'
        ]
      };
    }
  }
);

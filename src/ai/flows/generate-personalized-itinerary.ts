// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {z} from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { parseDestinations } from '@/ai/utils/destination-parser';
import { logger } from '@/lib/logger';
import { generateItineraryWithOpenAI, isOpenAIConfigured } from '@/ai/openai-direct';
import { generateChunkedItinerary } from '@/ai/openai-chunked';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  // ‚ö†Ô∏è CRITICAL: NEVER USE MOCK DATA!
  // ‚úÖ ALL data MUST come from OpenAI API
  // ‚ùå NO hardcoded itineraries allowed
  // ‚ùå NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '‚ùå CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  if (!isOpenAIConfigured()) {
    console.error('‚ùå [Server] OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  console.log('ü§ñ [Server] Using OpenAI GPT-4o-mini for generation');
  logger.info('AI', 'Using OpenAI GPT-4o-mini for generation');
  
  try {
    // Parse destinations to check if it's a multi-destination trip
    const parsedTrip = parseDestinations(input.prompt);
    const isMultiDestination = parsedTrip.destinations.length > 1;
    const isLongTrip = parsedTrip.totalDays > 14;
    
    // Use chunked approach for multi-destination or long trips to avoid timeouts
    if (isMultiDestination || isLongTrip) {
      console.log('üîÑ [Server] Using CHUNKED generation for multi-destination trip');
      logger.info('AI', 'Using chunked generation', {
        destinations: parsedTrip.destinations.length,
        totalDays: parsedTrip.totalDays
      });
      
      const result = await generateChunkedItinerary(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      console.log('‚úÖ [Server] Chunked OpenAI generation successful');
      return result;
    } else {
      // Use regular generation for simple trips
      const result = await generateItineraryWithOpenAI(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      console.log('‚úÖ [Server] OpenAI generation successful');
      return result;
    }
  } catch (error: any) {
    console.error('‚ùå [Server] OpenAI generation failed:', error.message);
    logger.error('AI', 'OpenAI generation failed', error);
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

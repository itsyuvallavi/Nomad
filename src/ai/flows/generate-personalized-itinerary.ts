
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import { config } from 'dotenv';
config();

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { GeneratePersonalizedItineraryOutputSchema } from '@/ai/schemas';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { findAccommodation, findRestaurants, findWorkspaces, findAttractions } from '@/lib/api/foursquare';
import { getWeatherForecast, getWeatherSummary } from '@/lib/api/weather';
import { validateAPIKeys, logAPIKeyStatus } from '@/lib/api-validation';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  return generatePersonalizedItineraryFlow(input);
}

const estimateFlightTime = ai.defineTool(
  {
    name: 'estimateFlightTime',
    description: 'Estimates flight time between two cities. Use this for adding flight information to the itinerary.',
    inputSchema: z.object({
      origin: z.string().describe('Origin city (e.g., "London", "New York")'),
      destination: z.string().describe('Destination city (e.g., "Paris", "Tokyo")'),
    }),
    outputSchema: z.object({
      duration: z.string().describe('Estimated flight duration'),
      departureAirport: z.string().describe('Main airport in origin city'),
      arrivalAirport: z.string().describe('Main airport in destination city'),
    }),
  },
  async (input) => {
    console.log('\n‚úàÔ∏è [Flight Tool] CALLED by AI model');
    console.log('‚úàÔ∏è [Flight Tool] Estimating flight:', input.origin, '‚Üí', input.destination);
    
    // Common flight routes with approximate times
    const routes: Record<string, Record<string, {duration: string, airports: [string, string]}>> = {
      'london': {
        'paris': { duration: '1h 15min', airports: ['London Heathrow (LHR)', 'Paris Charles de Gaulle (CDG)'] },
        'lisbon': { duration: '2h 45min', airports: ['London Heathrow (LHR)', 'Lisbon Airport (LIS)'] },
        'barcelona': { duration: '2h 15min', airports: ['London Gatwick (LGW)', 'Barcelona El Prat (BCN)'] },
        'rome': { duration: '2h 30min', airports: ['London Heathrow (LHR)', 'Rome Fiumicino (FCO)'] },
        'amsterdam': { duration: '1h 20min', airports: ['London City (LCY)', 'Amsterdam Schiphol (AMS)'] },
        'new york': { duration: '7h 30min', airports: ['London Heathrow (LHR)', 'JFK International (JFK)'] },
      },
      'new york': {
        'los angeles': { duration: '5h 30min', airports: ['JFK International (JFK)', 'LAX International (LAX)'] },
        'london': { duration: '7h 00min', airports: ['JFK International (JFK)', 'London Heathrow (LHR)'] },
        'paris': { duration: '8h 00min', airports: ['JFK International (JFK)', 'Paris Charles de Gaulle (CDG)'] },
        'miami': { duration: '3h 00min', airports: ['LaGuardia (LGA)', 'Miami International (MIA)'] },
      },
      'paris': {
        'london': { duration: '1h 15min', airports: ['Paris Charles de Gaulle (CDG)', 'London Heathrow (LHR)'] },
        'rome': { duration: '2h 00min', airports: ['Paris Orly (ORY)', 'Rome Fiumicino (FCO)'] },
        'barcelona': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Barcelona El Prat (BCN)'] },
        'lisbon': { duration: '2h 30min', airports: ['Paris Orly (ORY)', 'Lisbon Airport (LIS)'] },
        'amsterdam': { duration: '1h 10min', airports: ['Paris Charles de Gaulle (CDG)', 'Amsterdam Schiphol (AMS)'] },
        'berlin': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Berlin Brandenburg (BER)'] },
      },
      'lisbon': {
        'london': { duration: '2h 45min', airports: ['Lisbon Airport (LIS)', 'London Heathrow (LHR)'] },
        'paris': { duration: '2h 30min', airports: ['Lisbon Airport (LIS)', 'Paris Orly (ORY)'] },
        'madrid': { duration: '1h 20min', airports: ['Lisbon Airport (LIS)', 'Madrid Barajas (MAD)'] },
        'barcelona': { duration: '1h 50min', airports: ['Lisbon Airport (LIS)', 'Barcelona El Prat (BCN)'] },
      },
      'tokyo': {
        'london': { duration: '12h 30min', airports: ['Narita International (NRT)', 'London Heathrow (LHR)'] },
        'new york': { duration: '14h 00min', airports: ['Narita International (NRT)', 'JFK International (JFK)'] },
        'singapore': { duration: '7h 00min', airports: ['Narita International (NRT)', 'Singapore Changi (SIN)'] },
        'seoul': { duration: '2h 30min', airports: ['Narita International (NRT)', 'Incheon International (ICN)'] },
      },
    };
    
    const originLower = input.origin.toLowerCase();
    const destLower = input.destination.toLowerCase();
    
    // Check if we have this route
    if (routes[originLower]?.[destLower]) {
      const route = routes[originLower][destLower];
      console.log('‚úÖ [Flight Tool] Found route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[0],
        arrivalAirport: route.airports[1],
      };
    }
    
    // Check reverse route
    if (routes[destLower]?.[originLower]) {
      const route = routes[destLower][originLower];
      console.log('‚úÖ [Flight Tool] Found reverse route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[1],
        arrivalAirport: route.airports[0],
      };
    }
    
    // Default estimate based on distance
    console.log('‚ö†Ô∏è [Flight Tool] Route not in database, using estimate');
    return {
      duration: '3h 00min (estimated)',
      departureAirport: `${input.origin} International Airport`,
      arrivalAirport: `${input.destination} International Airport`,
    };
  }
);

const getWeatherForecastTool = ai.defineTool(
    {
        name: 'getWeatherForecast',
        description: 'MANDATORY: Gets the real weather forecast for a specific location. Call this FIRST before planning activities.',
        inputSchema: z.object({
            location: z.string().describe('The city name (e.g., "Lisbon", "Paris", "Tokyo").'),
        }),
        outputSchema: z.object({
            forecast: z.string().describe('Weather summary for the location.'),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        const apiKey = process.env.OPENWEATHERMAP;
        if (!apiKey || apiKey.length < 20) {
            console.warn('‚ö†Ô∏è [Weather Tool] API key is missing or invalid.');
            return { 
                forecast: "Weather: Typical seasonal conditions expected (API key not configured)", 
                success: false 
            };
        }
        console.log('\nüîî [Weather Tool] CALLED by AI model');
        console.log('üå§Ô∏è [Weather Tool] Getting weather for:', input.location);
        try {
            const weatherData = await getWeatherForecast(input.location, 5);
            if (weatherData && weatherData.length > 0) {
                const summary = weatherData.slice(0, 3)
                    .map(w => `${w.date}: ${w.weather.main}, ${w.temp.min}-${w.temp.max}¬∞C`)
                    .join('; ');
                console.log('‚úÖ [Weather Tool] SUCCESS - Got real weather data from OpenWeatherMap API');
                console.log('   üìä Weather summary:', summary);
                return { forecast: summary, success: true };
            }
        } catch (error) {
            console.error('‚ùå [Weather Tool] API error:', error);
        }
        return { forecast: "Weather: Moderate temperatures expected", success: false };
    }
);

const findRealPlacesTool = ai.defineTool(
    {
        name: 'findRealPlaces',
        description: 'MANDATORY: Finds REAL places in a destination. You MUST use this for EVERY place in the itinerary.',
        inputSchema: z.object({
            destination: z.string().describe('The city to search (e.g., "Lisbon", "Paris", "Tokyo").'),
            placeType: z.enum(['accommodation', 'restaurant', 'workspace', 'attraction']).describe('Type of place to find.'),
            limit: z.number().optional().default(5).describe('Number of results (default: 5).'),
        }),
        outputSchema: z.object({
            places: z.array(z.object({
                name: z.string(),
                address: z.string(),
                category: z.string().optional(),
                rating: z.number().optional(),
            })),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        if (!process.env.FOURSQUARE_API_KEY) {
            console.error('‚ùå [Places Tool] API key is missing. Please set FOURSQUARE_API_KEY in your .env file.');
            return { 
                places: [{
                    name: `Could not search for ${input.placeType}`,
                    address: `Foursquare API key is missing.`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
        console.log('\nüîî [Places Tool] CALLED by AI model');
        console.log('üîç [Places Tool] Searching for', input.placeType, 'in', input.destination);
        console.log('üìç [Places Tool] Request details:', JSON.stringify(input));
        
        try {
            let places: any[] = [];
            const searchLimit = input.limit || 5;
            
            switch (input.placeType) {
                case 'accommodation':
                    places = await findAccommodation(input.destination);
                    break;
                case 'restaurant':
                    places = await findRestaurants(input.destination, undefined, searchLimit);
                    break;
                case 'workspace':
                    places = await findWorkspaces(input.destination, searchLimit);
                    break;
                case 'attraction':
                    places = await findAttractions(input.destination, searchLimit);
                    break;
            }
            
            console.log(`‚úÖ [Places Tool] FOURSQUARE API SUCCESS - Found ${places.length} real places`);
            console.log('üè¢ [Places Tool] Places from Foursquare:');
            places.slice(0, 3).forEach((p, i) => {
                console.log(`   ${i + 1}. ${p.name}`);
                console.log(`      üìç Address: ${p.location?.formatted_address || 'No address'}`);
            });
            
            if (places.length === 0) {
                console.warn('‚ö†Ô∏è [Places Tool] No places found, returning defaults');
                // Return some default places as fallback
                return {
                    places: [{
                        name: `${input.placeType} in ${input.destination}`,
                        address: `${input.destination} city center`,
                        category: input.placeType,
                        rating: 4.0
                    }],
                    success: false
                };
            }
            
            const result = {
                places: places.slice(0, searchLimit).map(p => ({
                    name: p.name || `${input.placeType} venue`,
                    address: p.location?.formatted_address || `${input.destination} area`,
                    category: p.categories?.[0]?.name || input.placeType,
                    rating: p.rating || undefined,
                })),
                success: true
            };
            
            console.log('üì¶ [Places Tool] Returning', result.places.length, 'places');
            result.places.forEach((p, i) => {
                console.log(`   ${i + 1}. ${p.name} - ${p.address}`);
            });
            
            return result;
        } catch (error) {
            console.error('‚ùå [Places Tool] API error:', error);
            return { 
                places: [{
                    name: `${input.placeType} in ${input.destination}`,
                    address: `${input.destination} city center`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
    }
);


const prompt = ai.definePrompt({
  name: 'generatePersonalizedItineraryPrompt',
  input: {schema: GeneratePersonalizedItineraryInputSchema},
  output: {schema: GeneratePersonalizedItineraryOutputSchema},
  tools: [estimateFlightTime, getWeatherForecastTool, findRealPlacesTool],
  config: {
    temperature: 0.7,
    maxOutputTokens: 8192,
  },
  prompt: `You are a master travel agent specializing in creating personalized itineraries for nomad travelers. Your response must be a detailed day-by-day itinerary in a structured JSON format.

  **CRITICAL DATE HANDLING:**
  Today's date is: ` + new Date().toISOString().split('T')[0] + `
  Current year: ` + new Date().getFullYear() + `
  
  1. Extract the EXACT dates from the user's prompt
  2. ALWAYS use the CURRENT YEAR (` + new Date().getFullYear() + `) unless user specifies otherwise
  3. If user says "January 15-20", use ` + new Date().getFullYear() + `-01-15 to ` + new Date().getFullYear() + `-01-20
  4. If user says "5 days starting March 1st", calculate dates starting ` + new Date().getFullYear() + `-03-01
  5. If user says "next week", calculate from today's date: ` + new Date().toISOString().split('T')[0] + `
  6. ALWAYS use YYYY-MM-DD format for dates
  7. The number of days in the itinerary MUST match the trip duration

  Analyze the user's prompt to extract:
  - Trip duration and EXACT dates (very important!)
  - Destination(s) 
  - Origin/departure location (CRITICAL for flight information)
  - Any specific preferences mentioned
  
  **IMPORTANT**: Store the origin location for adding flight information

  User's request: {{{prompt}}}

  **SMART DEFAULTS TO USE (unless user specifies otherwise):**
  - **Budget:** Moderate budget of $150-200 per day per person (covers accommodation, meals, activities, and local transport)
  - **Accommodation:** Mid-range hotels or quality Airbnbs ($60-100/night)
  - **Activities:** Mix of:
    ‚Ä¢ Popular tourist highlights (must-see landmarks)
    ‚Ä¢ Local cultural experiences (markets, neighborhoods)
    ‚Ä¢ Food experiences (local restaurants, cafes, food tours)
    ‚Ä¢ Some free/low-cost activities (parks, walking tours, viewpoints)
  - **Travel Style:** Balanced comfort and adventure (not too rushed, 2-3 main activities per day)
  - **Meals:** Mix of local restaurants (breakfast $10-15, lunch $15-25, dinner $25-40)

  **MANDATORY TOOL USAGE - YOU MUST FOLLOW THIS EXACTLY:**
  
  STEP 1: Call estimateFlightTime tool
  - Input: origin and destination cities
  - This gives you flight duration and airport names
  
  STEP 2: Call getWeatherForecast tool
  - Input: destination city name
  - This gives you real weather for planning
  
  STEP 3: Call findRealPlaces for accommodation
  - Input: destination, placeType: 'accommodation', limit: 5
  - Pick ONE real hotel from the results
  
  STEP 4: For EACH day, call findRealPlaces multiple times:
  - Morning: findRealPlaces with placeType: 'restaurant' for breakfast
  - Daytime: findRealPlaces with placeType: 'attraction' for activities
  - Lunch: findRealPlaces with placeType: 'restaurant' 
  - Afternoon: findRealPlaces with placeType: 'workspace' or 'attraction'
  - Dinner: findRealPlaces with placeType: 'restaurant'
  
  **FLIGHT INFORMATION (MANDATORY - USE estimateFlightTime TOOL):**
  - DAY 1 FIRST ACTIVITY: Must be the departure flight
    - Time: "Early Morning" or "Morning" 
    - Description: "Flight from [Origin] to [Destination] (Duration: [from tool])"
    - Category: "Travel"
    - Address: Use the airports from estimateFlightTime tool
  
  - LAST DAY LAST ACTIVITY: Must be the return flight
    - Time: "Evening" or "Late Afternoon"
    - Description: "Return flight from [Destination] to [Origin] (Duration: [from tool])"
    - Category: "Travel"
    - Address: Use the airports from estimateFlightTime tool
  
  **CRITICAL RULES:**
  1. NEVER make up place names - ONLY use results from findRealPlaces tool (except for flights)
  2. Each place in your itinerary MUST come from a tool call (except flights which you generate)
  3. Include the ACTUAL address returned by the API
  4. If a tool returns empty results, call it again with different parameters
  5. Your itinerary MUST contain real places with real addresses
  6. ALWAYS include flights: departure flight on Day 1 and return flight on last day
  7. Extract and use the origin location from the user's prompt for flight information

  {{#if attachedFile}}
  The user has also attached a file for reference. Use this to inform the itinerary.
  Attached file: {{media url=attachedFile}}
  {{/if}}

  **OUTPUT REQUIREMENTS:**
  - Keep activity descriptions concise (1-2 sentences max)
  - Include practical details (opening hours, costs, booking needs)
  - Add 3-5 relevant quick tips for the destination
  - CRITICAL: Dates MUST align with user's specified travel dates (not arbitrary dates!)
  - Each day's date field must be in YYYY-MM-DD format
  - The itinerary array must have exactly the number of days matching the trip duration
  - Balance the itinerary: don't overschedule, allow for flexibility

  **FINAL OUTPUT REQUIREMENTS:**
  You MUST return a valid JSON object with ALL of these fields:
  - destination: string (the city/location)
  - title: string (a catchy trip title)
  - itinerary: array of day objects, each with:
    - day: number
    - date: string in YYYY-MM-DD format using year ` + new Date().getFullYear() + `
    - title: string
    - activities: array with time, description, category, address fields
  - quickTips: array of 3-5 string tips
  
  NEVER return null or undefined. Always return a complete JSON structure.
  `,
});

const generatePersonalizedItineraryFlow = ai.defineFlow(
  {
    name: 'generatePersonalizedItineraryFlow',
    inputSchema: GeneratePersonalizedItineraryInputSchema,
    outputSchema: GeneratePersonalizedItineraryOutputSchema,
  },
  async (input) => {
    console.log('='.repeat(80));
    console.log('üöÄ [ITINERARY GENERATION] Starting generation process...');
    console.log('üì• [ITINERARY GENERATION] Input prompt:', input.prompt);
    console.log('üìÖ [ITINERARY GENERATION] Today\'s date:', new Date().toISOString().split('T')[0]);
    console.log('üìÖ [ITINERARY GENERATION] Current year:', new Date().getFullYear());
    console.log('üîß [ITINERARY GENERATION] Tools available: getWeatherForecast, findRealPlaces');
    
    // Validate API keys at the start
    const apiKeys = validateAPIKeys();
    logAPIKeyStatus(apiKeys);
    
    // Check if critical keys are missing
    if (!apiKeys.gemini.isValid) {
      console.error('‚ùå [ITINERARY GENERATION] Cannot proceed without Gemini API key');
      throw new Error('AI service is not configured. Please ensure GEMINI_API_KEY is set in your .env file.');
    }
    
    console.log('='.repeat(80));
    
    try {
      const {output, usage} = await prompt(input);

      console.log('üìä [ITINERARY GENERATION] LLM Usage:', usage);
      console.log('üéØ [ITINERARY GENERATION] AI Model Response Received');
      
      // Only log first 500 chars of output to avoid clutter
      const outputStr = JSON.stringify(output, null, 2);
      console.log('üìù [ITINERARY GENERATION] Output preview:', outputStr.substring(0, 500) + '...');
      
      if (!output || output === null) {
        console.error('‚ùå [ITINERARY GENERATION] AI returned null or undefined');
        throw new Error('AI model returned null - retrying with fallback');
      }
      
      // Log what we're generating
      if (output.itinerary && Array.isArray(output.itinerary)) {
        console.log('‚úÖ [ITINERARY GENERATION] Successfully generated itinerary:');
        console.log(`   üìç Destination: ${output.destination}`);
        console.log(`   üìÖ Days: ${output.itinerary.length}`);
        
        // Verify dates are sequential and make sense
        let prevDate: Date | null = null;
        output.itinerary.forEach(day => {
          console.log(`   üìÜ Day ${day.day} (${day.date}): ${day.title}`);
          console.log(`      Activities: ${day.activities.length}`);
          
          // Check date sequence
          const currentDate = new Date(day.date);
          if (prevDate) {
            const dayDiff = Math.round((currentDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24));
            if (dayDiff !== 1) {
              console.warn(`      ‚ö†Ô∏è DATE ISSUE: Gap of ${dayDiff} days between Day ${day.day - 1} and Day ${day.day}`);
            }
          }
          prevDate = currentDate;
          
          // Log each activity to verify it's from APIs
          day.activities.forEach((activity, idx) => {
            console.log(`      Activity ${idx + 1}:`);
            console.log(`         ‚è∞ Time: ${activity.time}`);
            console.log(`         üìù Description: ${activity.description}`);
            console.log(`         üìç ADDRESS: ${activity.address || 'NO ADDRESS PROVIDED'}`);
            console.log(`         üè∑Ô∏è Category: ${activity.category}`);
            
            // Check if this is a flight
            if (activity.category === 'Travel' && activity.description.toLowerCase().includes('flight')) {
              console.log(`         ‚úàÔ∏è FLIGHT: This is a flight activity`);
              if (activity.address.includes('Airport')) {
                console.log(`         ‚úÖ DATA SOURCE: Flight tool (with real airports)`);
              } else {
                console.log(`         ‚ö†Ô∏è WARNING: Flight missing proper airport information`);
              }
            } else {
              // Check if this looks like real API data
              const hasRealAddress = activity.address && 
                                    activity.address !== 'N/A' && 
                                    activity.address !== 'Address not available' &&
                                    activity.address !== 'Location pending' &&
                                    !activity.address.includes('city center');
              
              if (hasRealAddress) {
                console.log(`         ‚úÖ DATA SOURCE: REAL API DATA (Foursquare)`);
              } else {
                console.log(`         ‚ö†Ô∏è DATA SOURCE: DEFAULT/PLACEHOLDER - NOT FROM API`);
              }
            }
          });
        });
      }
      
      // Validate critical fields
      if (!output.destination || !output.title) {
        console.error('‚ùå [ITINERARY GENERATION] Missing destination or title');
        throw new Error('Invalid itinerary structure - missing required fields');
      }
      
      // Ensure we have a valid itinerary array
      if (!output.itinerary || !Array.isArray(output.itinerary) || output.itinerary.length === 0) {
        console.error('‚ùå [ITINERARY GENERATION] Invalid or empty itinerary array');
        throw new Error('Invalid itinerary structure - empty or invalid itinerary array');
      }
      
      // Validate each day has required fields
      for (const day of output.itinerary) {
        if (!day.date || !day.activities || day.activities.length === 0) {
          console.error('‚ùå [ITINERARY GENERATION] Invalid day structure:', day);
          throw new Error(`Invalid day ${day.day} - missing date or activities`);
        }
      }
      
      console.log('='.repeat(80));
      return output;
    } catch (error) {
      console.error('‚ùå [ITINERARY GENERATION] Error:', error);
      console.log('üîÑ [ITINERARY GENERATION] Attempting retry with simplified prompt...');
      
      // Try once more with a simpler approach
      try {
        const simpleInput = {
          ...input,
          prompt: input.prompt + '\n\nIMPORTANT: You MUST return a valid JSON itinerary structure. Use the year ' + new Date().getFullYear() + ' for all dates.'
        };
        
        const {output: retryOutput} = await prompt(simpleInput);
        
        if (retryOutput && retryOutput.itinerary && retryOutput.itinerary.length > 0) {
          console.log('‚úÖ [ITINERARY GENERATION] Retry successful');
          return retryOutput;
        }
      } catch (retryError) {
        console.error('‚ùå [ITINERARY GENERATION] Retry also failed:', retryError);
      }
      
      // Return a valid fallback structure
      const today = new Date();
      const dates = [];
      for (let i = 0; i < 3; i++) {
        const date = new Date(today);
        date.setDate(date.getDate() + i);
        dates.push(date.toISOString().split('T')[0]);
      }
      
      return {
        destination: 'Your Destination',
        title: 'Trip Itinerary',
        itinerary: [{
          day: 1,
          date: dates[0],
          title: 'Day 1 - Arrival',
          activities: [{
            time: 'Morning',
            description: 'We\'re having trouble connecting to our travel APIs. Please check your connection and try again.',
            category: 'Travel' as const,
            address: 'Location pending'
          }]
        }],
        quickTips: [
          'Ensure you have a stable internet connection',
          'Try specifying a major city as your destination',
          'Include specific dates in your request'
        ]
      };
    }
  }
);

    
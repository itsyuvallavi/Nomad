// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {z} from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
// Only using AI parser now - no regex fallbacks
import { parseDestinationsWithAI } from '@/ai/utils/ai-destination-parser';
import { logger } from '@/lib/logger';
import { generateUnifiedItinerary, getUnifiedGenerator } from '@/ai/utils/unified-generator';
import { validateTripComplexity } from '@/ai/utils/enhanced-generator';
// Keep ultra-fast for now as primary until fully tested
import { generateUltraFastItinerary } from '@/ai/utils/enhanced-generator-ultra-fast';
import { logAIRequest, logAIResponse, logAIError } from '@/lib/utils/ai-logger';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  // Log the incoming request
  const requestId = await logAIRequest(input.prompt, {
    model: 'gpt-4o-mini',
    strategy: 'ultra-fast'
  });
  
  // Combine prompt with conversation history for better context
  let actualPrompt = input.prompt;
  if (input.conversationHistory) {
    // Include full conversation history for AI parser to understand context
    actualPrompt = input.conversationHistory + '\n' + input.prompt;
  }
  
  // Log to browser console if in client-side environment
  if (typeof window !== 'undefined') {
    console.group('üöÄ Generate Personalized Itinerary');
    console.log('üìù Initial prompt:', input.prompt);
    console.log('üí¨ Actual prompt from history:', actualPrompt);
    console.log('üìé Has attachment:', !!input.attachedFile);
    console.log('üí¨ Has conversation history:', !!input.conversationHistory);
    console.groupEnd();
  }
  
  // ‚ö†Ô∏è CRITICAL: NEVER USE MOCK DATA!
  // ‚úÖ ALL data MUST come from OpenAI API
  // ‚ùå NO hardcoded itineraries allowed
  // ‚ùå NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '‚ùå CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  const generator = getUnifiedGenerator();
  if (!generator.isConfigured()) {
    logger.error('SYSTEM', 'OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  // First validate trip complexity
  const validation = validateTripComplexity(actualPrompt);
  if (!validation.valid) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è Validation check:', validation.error);
    }
    // Log as info, not error, since this is expected user input validation
    logger.info('AI', 'Trip validation - needs more info', { reason: validation.error });
    
    // Make the error message more user-friendly for the UI
    const userFriendlyError = validation.error?.includes('multiple continents') || 
                              validation.error?.includes('too many destinations') ||
                              validation.error?.includes('too long') ||
                              validation.error?.includes('too complex')
      ? "Your search is too complex for our beta version. Try a simpler trip with fewer destinations!"
      : validation.error;
    
    // Return a special response for validation errors instead of throwing
    return {
      destination: 'Input Validation',
      title: 'More Information Needed',
      itinerary: [],
      quickTips: [
        "Try planning a trip with fewer destinations (maximum 5 cities)",
        "Consider shorter trips (maximum 30 days total)",
        "Focus on one region or continent for better planning"
      ],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: userFriendlyError || "Please provide more details about your trip"
    } as any;
  }
  
  // ONLY use AI-powered parsing - no fallbacks to regex
  let parsedTrip;
  
  try {
    parsedTrip = await parseDestinationsWithAI(actualPrompt);
    logger.info('AI', 'ü§ñ AI parser results', {
      origin: parsedTrip.origin,
      destinations: parsedTrip.destinations.length,
      totalDays: parsedTrip.totalDays
    });
  } catch (error: any) {
    logger.error('AI', 'AI parser failed', error);
    // Return error to user instead of falling back
    return {
      destination: 'Parser Error',
      title: 'Unable to Parse Trip',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: `I couldn't understand your trip request. Please try rephrasing it. Error: ${error.message}`
    } as any;
  }
  
  // Origin is completely optional now - we don't need it for trip planning
  let origin = parsedTrip.origin || '';
  
  // Only validate if destinations are missing
  if (!parsedTrip.destinations || parsedTrip.destinations.length === 0) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è No destinations found - throwing error for UI popup');
    }
    logger.info('AI', 'No destinations found - throwing error for UI');
    
    return {
      destination: 'Input Validation',
      title: 'Destination Required',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: `I couldn't understand your destination. Please specify where you'd like to travel, like "3 days in London" or "Weekend trip to Paris"`
    } as any;
  }
  
  // If origin is missing, just log it but continue - it's not required
  if (!origin || origin === '') {
    logger.info('AI', 'Origin not provided - this is fine, we can plan without it');
    origin = ''; // Keep it empty, no placeholder needed
  }
  
  // Update parsedTrip with the found origin
  parsedTrip.origin = origin;
  
  if (typeof window !== 'undefined') {
    console.log('‚úÖ Trip complexity validated');
    console.log('‚úàÔ∏è Origin detected:', parsedTrip.origin);
  }
  logger.info('AI', 'Trip complexity validated - proceeding with generation');
  
  // Use enhanced generator if we have the APIs configured
  const hasGoogleAPI = !!process.env.GOOGLE_API_KEY;
  const hasWeatherAPI = !!process.env.OPENWEATHERMAP;
  const hasGeminiAPI = !!process.env.GEMINI_API_KEY;
  const useEnhanced = hasGoogleAPI || hasWeatherAPI;
  
  if (useEnhanced) {
    if (typeof window !== 'undefined') {
      console.log('üéØ Using ENHANCED generation with APIs:', {
        Google: hasGoogleAPI,
        Weather: hasWeatherAPI,
        Gemini: hasGeminiAPI
      });
    }
    
    logger.info('AI', 'Using ENHANCED generation with multiple APIs', {
      hasGoogle: hasGoogleAPI,
      hasWeather: hasWeatherAPI,
      hasGemini: hasGeminiAPI
    });
    
    try {
      // Always use ultra-fast version for best performance
      const result = await generateUltraFastItinerary(
        actualPrompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      if (typeof window !== 'undefined') {
        console.log('‚ö° Ultra-fast generation successful');
      }
      logger.info('AI', 'Ultra-fast generation successful');
      
      // Log successful response
      await logAIResponse(requestId, result, {
        model: 'gpt-4o-mini',
        strategy: 'ultra-fast',
        destinations: [result.destination],
        totalDays: result.itinerary?.length || 0
      });
      
      return result;
    } catch (error: any) {
      if (typeof window !== 'undefined') {
        console.warn('‚ö†Ô∏è Enhanced generation failed, falling back:', error.message);
      }
      logger.error('AI', 'Enhanced generation failed, falling back to standard', { error: error.message });
      
      // Log the error
      await logAIError(requestId, error, {
        model: 'gpt-4o-mini',
        strategy: 'ultra-fast'
      });
      
      // Fall through to standard generation
    }
  }
  
  // Fallback to unified generation
  if (typeof window !== 'undefined') {
    console.log('ü§ñ Using unified OpenAI generation');
  }
  logger.info('AI', 'Using unified OpenAI generation');
  
  try {
    const result = await generateUnifiedItinerary(
      actualPrompt,
      input.attachedFile,
      input.conversationHistory
    );
    
    logger.info('AI', 'Unified OpenAI generation successful');
    
    // Log performance metrics
    const metrics = generator.getMetrics();
    logger.info('AI', 'Generation metrics', metrics);
    
    // Log successful response from unified generator
    await logAIResponse(requestId, result, {
      model: 'gpt-4o-mini',
      strategy: 'unified',
      destinations: [result.destination],
      totalDays: result.itinerary?.length || 0
    });
    
    return result;
  } catch (error: any) {
    logger.error('AI', 'Unified generation failed', { error: error.message, stack: error.stack });
    
    // Log the final error
    await logAIError(requestId, error, {
      model: 'gpt-4o-mini',
      strategy: 'unified'
    });
    
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

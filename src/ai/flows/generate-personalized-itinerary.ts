// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {z} from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { parseDestinations } from '@/ai/utils/destination-parser';
import { EnhancedDestinationParser } from '@/ai/utils/enhanced-destination-parser';
import { MasterTravelParser } from '@/lib/utils/master-parser';
import { logger } from '@/lib/logger';
import { generateUnifiedItinerary, getUnifiedGenerator } from '@/ai/utils/unified-generator';
import { validateTripComplexity } from '@/ai/utils/enhanced-generator';
// Keep ultra-fast for now as primary until fully tested
import { generateUltraFastItinerary } from '@/ai/utils/enhanced-generator-ultra-fast';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  // Extract the actual prompt from conversation history if available
  let actualPrompt = input.prompt;
  if (input.conversationHistory) {
    // Parse conversation history to get the last user message
    const lines = input.conversationHistory.split('\n');
    const lastUserLine = lines.filter(line => line.startsWith('user:')).pop();
    if (lastUserLine) {
      actualPrompt = lastUserLine.replace('user:', '').trim();
    }
  }
  
  // Log to browser console if in client-side environment
  if (typeof window !== 'undefined') {
    console.group('üöÄ Generate Personalized Itinerary');
    console.log('üìù Initial prompt:', input.prompt);
    console.log('üí¨ Actual prompt from history:', actualPrompt);
    console.log('üìé Has attachment:', !!input.attachedFile);
    console.log('üí¨ Has conversation history:', !!input.conversationHistory);
    console.groupEnd();
  }
  
  // ‚ö†Ô∏è CRITICAL: NEVER USE MOCK DATA!
  // ‚úÖ ALL data MUST come from OpenAI API
  // ‚ùå NO hardcoded itineraries allowed
  // ‚ùå NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '‚ùå CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  const generator = getUnifiedGenerator();
  if (!generator.isConfigured()) {
    logger.error('SYSTEM', 'OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  // First validate trip complexity
  const validation = validateTripComplexity(actualPrompt);
  if (!validation.valid) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è Validation check:', validation.error);
    }
    // Log as info, not error, since this is expected user input validation
    logger.info('AI', 'Trip validation - needs more info', { reason: validation.error });
    
    // Make the error message more user-friendly for the UI
    const userFriendlyError = validation.error?.includes('multiple continents') || 
                              validation.error?.includes('too many destinations') ||
                              validation.error?.includes('too long') ||
                              validation.error?.includes('too complex')
      ? "Your search is too complex for our beta version. Try a simpler trip with fewer destinations!"
      : validation.error;
    
    // Return a special response for validation errors instead of throwing
    return {
      destination: 'Input Validation',
      title: 'More Information Needed',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: userFriendlyError || "Please provide more details about your trip"
    } as any;
  }
  
  // Use master parser for Phase 2 improvements
  const masterResult = await MasterTravelParser.parseUserInput(actualPrompt);
  
  // Map master parser results to expected format
  const parsedTrip = masterResult.destinations.length > 0 ? {
    origin: masterResult.origin || '',
    destinations: masterResult.destinations.map(d => ({
      name: d.city,
      days: d.days
    })),
    totalDays: masterResult.duration,
    returnToOrigin: false
  } : parseDestinations(actualPrompt);
  
  // Also check conversation history for origin if not in current prompt
  let origin = parsedTrip.origin;
  if ((!origin || origin === '') && input.conversationHistory) {
    // Try enhanced parser on history
    const historyEnhanced = EnhancedDestinationParser.parse(input.conversationHistory);
    origin = historyEnhanced.origin || '';
    
    // Fall back to old parser if needed
    if (!origin) {
      const historyParsed = parseDestinations(input.conversationHistory);
      origin = historyParsed.origin || '';
    }
  }
  
  // Origin is optional - we can still generate an itinerary without it
  // Only validate if destinations are missing
  if (!parsedTrip.destinations || parsedTrip.destinations.length === 0) {
    if (typeof window !== 'undefined') {
      console.log('‚ÑπÔ∏è No destinations found - throwing error for UI popup');
    }
    logger.info('AI', 'No destinations found - throwing error for UI');
    
    return {
      destination: 'Input Validation',
      title: 'Destination Required',
      itinerary: [],
      quickTips: [],
      needsMoreInfo: true,
      validationError: true,
      errorMessage: `I couldn't understand your destination. Please specify where you'd like to travel, like "3 days in London" or "Weekend trip to Paris"`
    } as any;
  }
  
  // If origin is missing, just log it but continue
  if (!origin || origin === '') {
    logger.info('AI', 'Origin not provided, continuing without flight estimates');
    origin = 'Unknown'; // Use Unknown as placeholder
  }
  
  // Update parsedTrip with the found origin
  parsedTrip.origin = origin;
  
  if (typeof window !== 'undefined') {
    console.log('‚úÖ Trip complexity validated');
    console.log('‚úàÔ∏è Origin detected:', parsedTrip.origin);
  }
  logger.info('AI', 'Trip complexity validated - proceeding with generation');
  
  // Use enhanced generator if we have the APIs configured
  const hasGoogleAPI = !!process.env.GOOGLE_API_KEY;
  const hasWeatherAPI = !!process.env.OPENWEATHERMAP;
  const hasGeminiAPI = !!process.env.GEMINI_API_KEY;
  const useEnhanced = hasGoogleAPI || hasWeatherAPI;
  
  if (useEnhanced) {
    if (typeof window !== 'undefined') {
      console.log('üéØ Using ENHANCED generation with APIs:', {
        Google: hasGoogleAPI,
        Weather: hasWeatherAPI,
        Gemini: hasGeminiAPI
      });
    }
    
    logger.info('AI', 'Using ENHANCED generation with multiple APIs', {
      hasGoogle: hasGoogleAPI,
      hasWeather: hasWeatherAPI,
      hasGemini: hasGeminiAPI
    });
    
    try {
      // Always use ultra-fast version for best performance
      const result = await generateUltraFastItinerary(
        actualPrompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      if (typeof window !== 'undefined') {
        console.log('‚ö° Ultra-fast generation successful');
      }
      logger.info('AI', 'Ultra-fast generation successful');
      return result;
    } catch (error: any) {
      if (typeof window !== 'undefined') {
        console.warn('‚ö†Ô∏è Enhanced generation failed, falling back:', error.message);
      }
      logger.error('AI', 'Enhanced generation failed, falling back to standard', { error: error.message });
      // Fall through to standard generation
    }
  }
  
  // Fallback to unified generation
  if (typeof window !== 'undefined') {
    console.log('ü§ñ Using unified OpenAI generation');
  }
  logger.info('AI', 'Using unified OpenAI generation');
  
  try {
    const result = await generateUnifiedItinerary(
      actualPrompt,
      input.attachedFile,
      input.conversationHistory
    );
    
    logger.info('AI', 'Unified OpenAI generation successful');
    
    // Log performance metrics
    const metrics = generator.getMetrics();
    logger.info('AI', 'Generation metrics', metrics);
    
    return result;
  } catch (error: any) {
    logger.error('AI', 'Unified generation failed', { error: error.message, stack: error.stack });
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

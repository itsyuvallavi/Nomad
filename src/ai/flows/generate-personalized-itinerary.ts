// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {z} from 'genkit';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { parseDestinations } from '@/ai/utils/destination-parser';
import { logger } from '@/lib/logger';
import { generateItineraryWithOpenAI, isOpenAIConfigured } from '@/ai/openai-direct';
import { generateChunkedItinerary } from '@/ai/openai-chunked';
import { generateEnhancedItinerary, validateTripComplexity } from '@/ai/enhanced-generator';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  // ⚠️ CRITICAL: NEVER USE MOCK DATA!
  // ✅ ALL data MUST come from OpenAI API
  // ❌ NO hardcoded itineraries allowed
  // ❌ NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '❌ CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  if (!isOpenAIConfigured()) {
    logger.error('SYSTEM', 'OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  // First validate trip complexity
  const validation = validateTripComplexity(input.prompt);
  if (!validation.valid) {
    logger.error('AI', 'Trip complexity validation failed', { error: validation.error });
    throw new Error(validation.error);
  }
  
  logger.info('AI', 'Trip complexity validated - proceeding with generation');
  
  // Use enhanced generator if we have the APIs configured
  const hasGoogleAPI = !!process.env.GOOGLE_API_KEY;
  const hasWeatherAPI = !!process.env.OPENWEATHERMAP;
  const hasGeminiAPI = !!process.env.GEMINI_API_KEY;
  const useEnhanced = hasGoogleAPI || hasWeatherAPI;
  
  if (useEnhanced) {
    logger.info('AI', 'Using ENHANCED generation with multiple APIs', {
      hasGoogle: hasGoogleAPI,
      hasWeather: hasWeatherAPI,
      hasGemini: hasGeminiAPI
    });
    
    try {
      const result = await generateEnhancedItinerary(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      logger.info('AI', 'Enhanced generation successful');
      return result;
    } catch (error: any) {
      logger.error('AI', 'Enhanced generation failed, falling back to standard', { error: error.message });
      // Fall through to standard generation
    }
  }
  
  // Fallback to standard generation
  logger.info('AI', 'Using standard OpenAI generation');
  
  try {
    // Parse destinations to check if it's a multi-destination trip
    const parsedTrip = parseDestinations(input.prompt);
    const isMultiDestination = parsedTrip.destinations.length > 1;
    // Use chunked for trips longer than 7 days to prevent timeouts
    const isLongTrip = parsedTrip.totalDays > 7;
    
    // Use chunked approach for multi-destination or long trips to avoid timeouts
    if (isMultiDestination || isLongTrip) {
      logger.info('AI', 'Using CHUNKED generation for multi-destination or long trip', {
        destinations: parsedTrip.destinations.length,
        totalDays: parsedTrip.totalDays,
        isMulti: isMultiDestination,
        isLong: isLongTrip,
      });
      
      const result = await generateChunkedItinerary(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      logger.info('AI', 'Chunked OpenAI generation successful');
      return result;
    } else {
      // Use regular generation for simple trips
      logger.info('AI', 'Using DIRECT generation for simple trip');
      const result = await generateItineraryWithOpenAI(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      logger.info('AI', 'Direct OpenAI generation successful');
      return result;
    }
  } catch (error: any) {
    logger.error('AI', 'OpenAI generation failed', { error: error.message, stack: error.stack });
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

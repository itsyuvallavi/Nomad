// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

const ActivitySchema = z.object({
  time: z
    .string()
    .describe('The time of the activity (e.g., "9:00 AM", "Afternoon").'),
  description: z.string().describe('A short, minimal description of the activity.'),
  category: z
    .enum(['Work', 'Leisure', 'Food', 'Travel', 'Accommodation'])
    .describe('The category of the activity.'),
  address: z.string().describe('The specific address of the activity location (e.g., "123 Main St, City, Country").'),
  travelTime: z
    .string()
    .optional()
    .describe('Estimated travel time from the previous location.'),
});

const DailyItinerarySchema = z.object({
  day: z.number().describe('The day number of the itinerary (e.g., 1).'),
  date: z
    .string()
    .describe('The date of the itinerary day in YYYY-MM-DD format.'),
  title: z
    .string()
    .describe('A title for the day (e.g., "Arrival and Settling In").'),
  activities: z
    .array(ActivitySchema)
    .describe('A list of activities for the day.'),
});

const GeneratePersonalizedItineraryOutputSchema = z.object({
  destination: z.string().describe('The main destination of the trip (e.g., "Lisbon, Portugal").'),
  title: z.string().describe('A catchy title for the trip (e.g., "Lisbon Work-cation Adventure").'),
  itinerary: z
    .array(DailyItinerarySchema)
    .describe('The generated day-by-day itinerary.'),
  quickTips: z.array(z.string()).describe('A list of 3-4 very short, helpful tips for the destination.'),
});

export type GeneratePersonalizedItineraryOutput = z.infer<
  typeof GeneratePersonalizedItineraryOutputSchema
>;

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  return generatePersonalizedItineraryFlow(input);
}

const decideOnEventOrLocation = ai.defineTool(
  {
    name: 'decideOnEventOrLocation',
    description:
      'Decides whether to incorporate a particular event or location into the itinerary based on user preferences.',
    inputSchema: z.object({
      eventOrLocation: z
        .string()
        .describe('The event or location to consider.'),
      userPreferences: z
        .string()
        .describe('The userâ€™s lifestyle preferences and interests.'),
    }),
    outputSchema: z.boolean(),
  },
  async (input) => {
    // A real implementation would compare the event/location to user preferences.
    // For now, we'll just include everything.
    return true;
  }
);

const prompt = ai.definePrompt({
  name: 'generatePersonalizedItineraryPrompt',
  input: {schema: GeneratePersonalizedItineraryInputSchema},
  output: {schema: GeneratePersonalizedItineraryOutputSchema},
  tools: [decideOnEventOrLocation],
  prompt: `You are a travel agent specializing in creating personalized itineraries for nomad travelers. Your response must be a detailed day-by-day itinerary in a structured JSON format.

  Analyze the user's prompt to determine the destination, travel dates, work requirements, visa status, budget, and lifestyle preferences.

  User's request: {{{prompt}}}

  **Important Rules:**
  1.  **Select Specific Places:** You MUST choose real, specific locations for all activities, including hotels, coworking spaces, restaurants, and points of interest. Provide a full, real address for each.
  2.  **Default Budget:** If the user does not specify a budget, you MUST assume a total daily budget of $500. This budget must cover everything for the day: hotel, three meals, transportation, and activities. Select places that fit within this budget.
  3.  **Minimal Text:** Keep all descriptions for activities short and to the point.
  4.  **Quick Tips:** The 'quickTips' array should contain 3-4 very brief, essential tips for the traveler.

  {{#if attachedFile}}
  The user has also attached a file for reference. Use the information in this file to inform the itinerary.
  Attached file: {{media url=attachedFile}}
  {{/if}}

  Today's date is ${new Date().toLocaleDateString()}. Make sure the dates in the itinerary are correct based on the user's travel dates.

  Incorporate coworking spaces, cafes with reliable WiFi, and local nomad community events into the itinerary. Use the decideOnEventOrLocation tool to determine whether a given event or location aligns with the user's preferences.

  For each activity, provide a time, a description, a category, a specific physical address, and an estimated travel time from the previous activity. Do not mention flights. The travel should be between locations within the destination city.

  The final output must include a 'destination' (e.g., "Lisbon, Portugal"), a 'title' for the trip, the 'itinerary' itself, and a list of 'quickTips'.

  Ensure every day has a clear title, date, and a list of activities.
  `,
});

const generatePersonalizedItineraryFlow = ai.defineFlow(
  {
    name: 'generatePersonalizedItineraryFlow',
    inputSchema: GeneratePersonalizedItineraryInputSchema,
    outputSchema: GeneratePersonalizedItineraryOutputSchema,
  },
  async (input) => {
    const {output} = await prompt(input);
    
    if (!output || !output.itinerary) {
      // If the model fails, try to return a graceful empty state
      // or a message indicating failure.
      // Returning a valid, empty structure is often better than null/undefined.
      return { destination: 'Unknown', title: 'Trip', itinerary: [], quickTips: [] };
    }
    
    return output;
  }
);

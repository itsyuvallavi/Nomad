
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Generates a personalized day-by-day itinerary based on user preferences.
 *
 * - generatePersonalizedItinerary - A function that generates the itinerary.
 * - GeneratePersonalizedItineraryInput - The input type for the generatePersonalizedItinerary function.
 * - GeneratePersonalizedItineraryOutput - The return type for the generatePersonalizedItinerary function.
 */
import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { GeneratePersonalizedItineraryOutputSchema } from '@/ai/schemas';
import type { GeneratePersonalizedItineraryOutput } from '@/ai/schemas';
import { findAccommodation, findRestaurants, findWorkspaces, findAttractions } from '@/lib/api/foursquare';
import { getWeatherForecast, getWeatherSummary } from '@/lib/api/weather';
import { validateAPIKeys, logAPIKeyStatus } from '@/lib/api-validation';
// ‚ùå REMOVED: import { mockItinerary } from '@/lib/mock-data'; - NO MOCK DATA ALLOWED!
import { parseDestinations, buildStructuredPrompt } from '@/ai/utils/destination-parser';
import { logger } from '@/lib/logger';
import { generateItineraryWithOpenAI, isOpenAIConfigured } from '@/ai/openai-direct';
import { generateChunkedItinerary } from '@/ai/openai-chunked';

const GeneratePersonalizedItineraryInputSchema = z.object({
  prompt: z
    .string()
    .describe('A natural language prompt describing the desired trip.'),
  attachedFile: z
    .string()
    .optional()
    .describe(
      "A file attached by the user as a data URI. Can be a document or an image. Format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  conversationHistory: z.string().optional().describe("A summary of the conversation so far, for context."),
});

export type GeneratePersonalizedItineraryInput = z.infer<
  typeof GeneratePersonalizedItineraryInputSchema
>;

export { type GeneratePersonalizedItineraryOutput };

export async function generatePersonalizedItinerary(
  input: GeneratePersonalizedItineraryInput
): Promise<GeneratePersonalizedItineraryOutput> {
  // ‚ö†Ô∏è CRITICAL: NEVER USE MOCK DATA!
  // ‚úÖ ALL data MUST come from OpenAI API
  // ‚ùå NO hardcoded itineraries allowed
  // ‚ùå NO fallback data allowed
  // This app MUST use REAL API data ALWAYS!
  
  if (process.env.USE_MOCK_DATA === 'true') {
    logger.error('AI', '‚ùå CRITICAL ERROR: Mock data requested but NOT ALLOWED!');
    throw new Error('MOCK DATA IS FORBIDDEN! All itineraries MUST come from real OpenAI API calls. Set USE_MOCK_DATA=false');
  }
  
  // ONLY USE OPENAI - NO GEMINI
  if (!isOpenAIConfigured()) {
    console.error('‚ùå [Server] OpenAI API key is not configured!');
    throw new Error('OpenAI API key is required. Please add OPENAI_API_KEY to your .env file.');
  }
  
  console.log('ü§ñ [Server] Using OpenAI GPT-4o-mini for generation');
  logger.info('AI', 'Using OpenAI GPT-4o-mini for generation');
  
  try {
    // Parse destinations to check if it's a multi-destination trip
    const parsedTrip = parseDestinations(input.prompt);
    const isMultiDestination = parsedTrip.destinations.length > 1;
    const isLongTrip = parsedTrip.totalDays > 14;
    
    // Use chunked approach for multi-destination or long trips to avoid timeouts
    if (isMultiDestination || isLongTrip) {
      console.log('üîÑ [Server] Using CHUNKED generation for multi-destination trip');
      logger.info('AI', 'Using chunked generation', {
        destinations: parsedTrip.destinations.length,
        totalDays: parsedTrip.totalDays
      });
      
      const result = await generateChunkedItinerary(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      console.log('‚úÖ [Server] Chunked OpenAI generation successful');
      return result;
    } else {
      // Use regular generation for simple trips
      const result = await generateItineraryWithOpenAI(
        input.prompt,
        input.attachedFile,
        input.conversationHistory
      );
      
      console.log('‚úÖ [Server] OpenAI generation successful');
      return result;
    }
  } catch (error: any) {
    console.error('‚ùå [Server] OpenAI generation failed:', error.message);
    logger.error('AI', 'OpenAI generation failed', error);
    throw new Error(`OpenAI generation failed: ${error.message}`);
  }
}

const estimateFlightTime = ai.defineTool(
  {
    name: 'estimateFlightTime',
    description: 'Estimates flight time between two cities. Use this for adding flight information to the itinerary.',
    inputSchema: z.object({
      origin: z.string().describe('Origin city (e.g., "London", "New York")'),
      destination: z.string().describe('Destination city (e.g., "Paris", "Tokyo")'),
    }),
    outputSchema: z.object({
      duration: z.string().describe('Estimated flight duration'),
      departureAirport: z.string().describe('Main airport in origin city'),
      arrivalAirport: z.string().describe('Main airport in destination city'),
    }),
  },
  async (input) => {
    logger.info('AI', '‚úàÔ∏è Flight Tool Called', {
      origin: input.origin,
      destination: input.destination
    });
    
    // Common flight routes with approximate times
    const routes: Record<string, Record<string, {duration: string, airports: [string, string]}>> = {
      'london': {
        'paris': { duration: '1h 15min', airports: ['London Heathrow (LHR)', 'Paris Charles de Gaulle (CDG)'] },
        'lisbon': { duration: '2h 45min', airports: ['London Heathrow (LHR)', 'Lisbon Airport (LIS)'] },
        'barcelona': { duration: '2h 15min', airports: ['London Gatwick (LGW)', 'Barcelona El Prat (BCN)'] },
        'rome': { duration: '2h 30min', airports: ['London Heathrow (LHR)', 'Rome Fiumicino (FCO)'] },
        'amsterdam': { duration: '1h 20min', airports: ['London City (LCY)', 'Amsterdam Schiphol (AMS)'] },
        'new york': { duration: '7h 30min', airports: ['London Heathrow (LHR)', 'JFK International (JFK)'] },
      },
      'new york': {
        'los angeles': { duration: '5h 30min', airports: ['JFK International (JFK)', 'LAX International (LAX)'] },
        'london': { duration: '7h 00min', airports: ['JFK International (JFK)', 'London Heathrow (LHR)'] },
        'paris': { duration: '8h 00min', airports: ['JFK International (JFK)', 'Paris Charles de Gaulle (CDG)'] },
        'miami': { duration: '3h 00min', airports: ['LaGuardia (LGA)', 'Miami International (MIA)'] },
      },
      'paris': {
        'london': { duration: '1h 15min', airports: ['Paris Charles de Gaulle (CDG)', 'London Heathrow (LHR)'] },
        'rome': { duration: '2h 00min', airports: ['Paris Orly (ORY)', 'Rome Fiumicino (FCO)'] },
        'barcelona': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Barcelona El Prat (BCN)'] },
        'lisbon': { duration: '2h 30min', airports: ['Paris Orly (ORY)', 'Lisbon Airport (LIS)'] },
        'amsterdam': { duration: '1h 10min', airports: ['Paris Charles de Gaulle (CDG)', 'Amsterdam Schiphol (AMS)'] },
        'berlin': { duration: '1h 45min', airports: ['Paris Charles de Gaulle (CDG)', 'Berlin Brandenburg (BER)'] },
      },
      'lisbon': {
        'london': { duration: '2h 45min', airports: ['Lisbon Airport (LIS)', 'London Heathrow (LHR)'] },
        'paris': { duration: '2h 30min', airports: ['Lisbon Airport (LIS)', 'Paris Orly (ORY)'] },
        'madrid': { duration: '1h 20min', airports: ['Lisbon Airport (LIS)', 'Madrid Barajas (MAD)'] },
        'barcelona': { duration: '1h 50min', airports: ['Lisbon Airport (LIS)', 'Barcelona El Prat (BCN)'] },
      },
      'tokyo': {
        'london': { duration: '12h 30min', airports: ['Narita International (NRT)', 'London Heathrow (LHR)'] },
        'new york': { duration: '14h 00min', airports: ['Narita International (NRT)', 'JFK International (JFK)'] },
        'singapore': { duration: '7h 00min', airports: ['Narita International (NRT)', 'Singapore Changi (SIN)'] },
        'seoul': { duration: '2h 30min', airports: ['Narita International (NRT)', 'Incheon International (ICN)'] },
      },
    };
    
    const originLower = input.origin.toLowerCase();
    const destLower = input.destination.toLowerCase();
    
    // Check if we have this route
    if (routes[originLower]?.[destLower]) {
      const route = routes[originLower][destLower];
      console.log('‚úÖ [Flight Tool] Found route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[0],
        arrivalAirport: route.airports[1],
      };
    }
    
    // Check reverse route
    if (routes[destLower]?.[originLower]) {
      const route = routes[destLower][originLower];
      console.log('‚úÖ [Flight Tool] Found reverse route:', route.duration);
      return {
        duration: route.duration,
        departureAirport: route.airports[1],
        arrivalAirport: route.airports[0],
      };
    }
    
    // Default estimate based on distance
    console.log('‚ö†Ô∏è [Flight Tool] Route not in database, using estimate');
    return {
      duration: '3h 00min (estimated)',
      departureAirport: `${input.origin} International Airport`,
      arrivalAirport: `${input.destination} International Airport`,
    };
  }
);

const getWeatherForecastTool = ai.defineTool(
    {
        name: 'getWeatherForecast',
        description: 'MANDATORY: Gets the real weather forecast for a specific location. Call this FIRST before planning activities.',
        inputSchema: z.object({
            location: z.string().describe('The city name (e.g., "Lisbon", "Paris", "Tokyo").'),
        }),
        outputSchema: z.object({
            forecast: z.string().describe('Weather summary for the location.'),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        const apiKey = process.env.OPENWEATHERMAP;
        if (!apiKey || apiKey.length < 20) {
            console.warn('‚ö†Ô∏è [Weather Tool] API key is missing or invalid.');
            return { 
                forecast: "Weather: Typical seasonal conditions expected (API key not configured)", 
                success: false 
            };
        }
        logger.info('WEATHER', 'üå§Ô∏è Weather Tool Called', {
          location: input.location
        });
        try {
            const weatherData = await getWeatherForecast(input.location, 5);
            if (weatherData && weatherData.length > 0) {
                const summary = weatherData.slice(0, 3)
                    .map(w => `${w.date}: ${w.weather.main}, ${w.temp.min}-${w.temp.max}¬∞C`)
                    .join('; ');
                console.log('‚úÖ [Weather Tool] SUCCESS - Got real weather data from OpenWeatherMap API');
                console.log('   üìä Weather summary:', summary);
                return { forecast: summary, success: true };
            }
        } catch (error) {
            console.error('‚ùå [Weather Tool] API error:', error);
        }
        return { forecast: "Weather: Moderate temperatures expected", success: false };
    }
);

const findRealPlacesTool = ai.defineTool(
    {
        name: 'findRealPlaces',
        description: 'MANDATORY: Finds REAL places in a destination. You MUST use this for EVERY place in the itinerary.',
        inputSchema: z.object({
            destination: z.string().describe('The city to search (e.g., "Lisbon", "Paris", "Tokyo").'),
            placeType: z.enum(['accommodation', 'restaurant', 'workspace', 'attraction']).describe('Type of place to find.'),
            limit: z.number().optional().default(5).describe('Number of results (default: 5).'),
        }),
        outputSchema: z.object({
            places: z.array(z.object({
                name: z.string(),
                address: z.string(),
                category: z.string().optional(),
                rating: z.number().optional(),
            })),
            success: z.boolean().describe('Whether the API call succeeded.')
        }),
    },
    async (input) => {
        if (!process.env.FOURSQUARE_API_KEY) {
            console.error('‚ùå [Places Tool] API key is missing. Please set FOURSQUARE_API_KEY in your .env file.');
            return { 
                places: [{
                    name: `Could not search for ${input.placeType}`,
                    address: `Foursquare API key is missing.`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
        logger.info('PLACES', 'üìç Places Tool Called', {
          placeType: input.placeType,
          destination: input.destination,
          limit: input.limit
        });
        
        try {
            let places: any[] = [];
            const searchLimit = input.limit || 5;
            
            switch (input.placeType) {
                case 'accommodation':
                    places = await findAccommodation(input.destination);
                    break;
                case 'restaurant':
                    places = await findRestaurants(input.destination, undefined, searchLimit);
                    break;
                case 'workspace':
                    places = await findWorkspaces(input.destination, searchLimit);
                    break;
                case 'attraction':
                    places = await findAttractions(input.destination, searchLimit);
                    break;
            }
            
            // Found real places from Foursquare
            
            if (places.length === 0) {
                // No places found, using defaults
                // Return some default places as fallback
                return {
                    places: [{
                        name: `${input.placeType} in ${input.destination}`,
                        address: `${input.destination} city center`,
                        category: input.placeType,
                        rating: 4.0
                    }],
                    success: false
                };
            }
            
            const result = {
                places: places.slice(0, searchLimit).map(p => ({
                    name: p.name || `${input.placeType} venue`,
                    address: p.location?.formatted_address || `${input.destination} area`,
                    category: p.categories?.[0]?.name || input.placeType,
                    rating: p.rating || undefined,
                })),
                success: true
            };
            
            // Returning places
            
            return result;
        } catch (error) {
            console.error('‚ùå [Places Tool] API error:', error);
            return { 
                places: [{
                    name: `${input.placeType} in ${input.destination}`,
                    address: `${input.destination} city center`,
                    category: input.placeType,
                    rating: undefined
                }],
                success: false 
            };
        }
    }
);


const prompt = ai.definePrompt({
  name: 'generatePersonalizedItineraryPrompt',
  input: {schema: GeneratePersonalizedItineraryInputSchema},
  output: {schema: GeneratePersonalizedItineraryOutputSchema},
  tools: [estimateFlightTime, getWeatherForecastTool, findRealPlacesTool],
  config: {
    temperature: 0.7,
    maxOutputTokens: 16384, // Increased for multi-destination trips
  },
  prompt: `You are a master travel agent specializing in creating personalized itineraries for nomad travelers. Your response must be a detailed day-by-day itinerary in a structured JSON format.

  **CRITICAL DATE HANDLING:**
  Today's date is: ${new Date().toISOString().split('T')[0]}
  Current year: ${new Date().getFullYear()}
  
  1. Extract the EXACT dates from the user's prompt.
  2. ALWAYS use the CURRENT YEAR (${new Date().getFullYear()}) unless the user specifies a different year.
  3. If user says "January 15-20", use ${new Date().getFullYear()}-01-15 to ${new Date().getFullYear()}-01-20.
  4. If user says "5 days starting March 1st", calculate dates starting ${new Date().getFullYear()}-03-01.
  5. If user says "next week", calculate from today's date: ${new Date().toISOString().split('T')[0]}.
  6. ALWAYS use YYYY-MM-DD format for dates.
  7. The number of days in the itinerary array MUST EXACTLY match the requested trip duration.

  **MULTI-DESTINATION TRIP HANDLING - CRITICAL:**
  If the user requests multiple destinations:
  1. Parse EACH destination with its EXACT duration (e.g., "Zimbabwe for 7 days" = 7 days in Zimbabwe)
  2. Create itinerary covering ALL destinations in the order mentioned
  3. Include travel days between cities (these are ADDITIONAL to stay duration)
  4. Title format for multi-city trips: "Day X: [City Name]" or "[City] Day Y"
  5. The destination field should list all cities: "Harare, Managua, Antananarivo, Copenhagen"
  
  Example: "Zimbabwe 7 days, Nicaragua a week, Madagascar a week, Ethiopia a week, Denmark 3 days"
  Should create: 7 days Zimbabwe + 1 travel + 7 days Nicaragua + 1 travel + 7 days Madagascar + 1 travel + 7 days Ethiopia + 1 travel + 3 days Denmark = 35 total days

  Analyze the user's request to extract:
  - Trip duration for EACH destination separately
  - ALL destinations in order (don't skip any!)
  - Origin/departure location (CRITICAL for flight information)
  - Any specific preferences mentioned
  
  User's request: {{{prompt}}}
  {{#if conversationHistory}}
  Conversation History: {{{conversationHistory}}}
  {{/if}}

  **SMART DEFAULTS TO USE (unless user specifies otherwise):**
  - **Budget:** Moderate budget of $150-200 per day per person.
  - **Accommodation:** Mid-range hotels or quality Airbnbs.
  - **Activities:** Mix of popular tourist highlights, local cultural experiences, and food.
  - **Travel Style:** Balanced comfort and adventure (5-7 activities per day including meals and rest).
  - **Meals:** Mix of local restaurants.
  
  **DAILY SCHEDULE REQUIREMENTS:**
  - Start each day between 8-9 AM (breakfast or morning activity)
  - Include a morning activity (10-11 AM)
  - Include lunch (12-1 PM)
  - Include 2-3 afternoon activities (2-6 PM)
  - Include dinner (7-8 PM)
  - Include an evening activity when appropriate (8-10 PM) - could be nightlife, sunset viewing, evening market, etc.
  - Include rest/relaxation periods between activities when needed
  - For digital nomads: Include at least 1 coworking/work session option per day

  **MANDATORY TOOL USAGE - YOU MUST FOLLOW THIS EXACTLY:**
  
  STEP 1: Call estimateFlightTime tool.
  
  STEP 2: Call getWeatherForecast tool.
  
  STEP 3: Call findRealPlaces for accommodation. Pick ONE real hotel from the results.
  
  STEP 4: For EACH day, call findRealPlaces multiple times for restaurants, attractions, etc.
  
  **FLIGHT INFORMATION (MANDATORY):**
  - DAY 1 FIRST ACTIVITY: Must be the departure flight.
  - LAST DAY LAST ACTIVITY: Must be the return flight.
  
  **CRITICAL RULES:**
  1. NEVER make up place names - ONLY use results from the findRealPlaces tool.
  2. Each place in your itinerary MUST come from a tool call (except flights).
  3. Include the ACTUAL address returned by the API.
  4. Your itinerary MUST contain real places with real addresses.
  5. ALWAYS include departure and return flights.
  6. Extract and use the origin location from the user's prompt for flight information.
  7. NEVER skip destinations - if user mentions 5 cities, ALL 5 must be in the itinerary.
  8. Use EXACT durations specified (7 days means 7 days, not 14 days).
  9. For multi-city trips, include inter-city travel as separate activities.

  {{#if attachedFile}}
  The user has also attached a file for reference. Use this to inform the itinerary.
  Attached file: {{media url=attachedFile}}
  {{/if}}

  **FINAL OUTPUT REQUIREMENTS:**
  You MUST return a valid JSON object with ALL of these fields:
  - destination: string (the city/location)
  - title: string (a catchy trip title)
  - itinerary: array of day objects, each with:
    - day: number
    - date: string in YYYY-MM-DD format using year ${new Date().getFullYear()}
    - title: string
    - activities: array with time, description, category, address fields
  - quickTips: array of 3-5 string tips
  
  NEVER return null or undefined. Always return a complete JSON structure. The itinerary array must have exactly the number of days matching the trip duration.
  `,
});

const generatePersonalizedItineraryFlow = ai.defineFlow(
  {
    name: 'generatePersonalizedItineraryFlow',
    inputSchema: GeneratePersonalizedItineraryInputSchema,
    outputSchema: GeneratePersonalizedItineraryOutputSchema,
  },
  async (input) => {
    // Validate API keys at the start
    const apiKeys = validateAPIKeys();
    logAPIKeyStatus(apiKeys);
    
    if (!apiKeys.gemini.isValid) {
      throw new Error('AI service is not configured. Please ensure GEMINI_API_KEY is set in your .env file.');
    }
    
    try {
      const {output, usage} = await prompt(input);

      if (!output || output === null) {
        console.error('‚ùå AI returned null or undefined');
        throw new Error('AI model returned null - retrying with fallback');
      }
      
      if (output.itinerary && Array.isArray(output.itinerary)) {
        logger.info('AI', '‚úÖ Itinerary generated successfully', {
          destination: output.destination,
          days: output.itinerary.length,
          title: output.title
        });
        
        // Validate multi-destination trips
        const requestedDestinations = input.prompt.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b(?=\s+(?:for|[\d]+\s*days?|a\s+week))/gi);
        if (requestedDestinations && requestedDestinations.length > 1) {
          const generatedCities = output.destination.split(',').map(d => d.trim());
          logger.info('AI', 'üìç Multi-destination validation', {
            requested: requestedDestinations,
            generated: generatedCities
          });
          
          // Check if all requested destinations are included
          const missingDestinations = requestedDestinations.filter(
            dest => !generatedCities.some(city => city.toLowerCase().includes(dest.toLowerCase()))
          );
          
          if (missingDestinations.length > 0) {
            logger.warn('AI', '‚ö†Ô∏è Missing destinations detected', {
              missing: missingDestinations,
              message: 'AI may need to be re-prompted to include all destinations'
            });
          }
        }
      }
      
      if (!output.destination || !output.title) {
        throw new Error('Invalid itinerary structure - missing required fields');
      }
      
      if (!output.itinerary || !Array.isArray(output.itinerary) || output.itinerary.length === 0) {
        throw new Error('Invalid itinerary structure - empty or invalid itinerary array');
      }
      
      // Validate each day has required fields
      for (const day of output.itinerary) {
        if (!day.date || !day.activities || day.activities.length === 0) {
          throw new Error(`Invalid day ${day.day} - missing date or activities`);
        }
        
        // Ensure day titles are present for multi-destination trips
        if (!day.title && output.destination.includes(',')) {
          console.warn(`‚ö†Ô∏è Day ${day.day} missing title - may affect location detection`);
        }
      }
      
      // Generation complete
      return output;
    } catch (error) {
      console.error('[ITINERARY GENERATION] Error:', error);
      
      // Include error details in the response for client-side debugging
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('[ITINERARY GENERATION] Error details:', errorMessage);
      
      const today = new Date();
      const dates = Array.from({ length: 3 }, (_, i) => {
        const date = new Date(today);
        date.setDate(date.getDate() + i);
        return date.toISOString().split('T')[0];
      });
      
      return {
        destination: 'Your Destination',
        title: 'Trip Itinerary - Error: ' + errorMessage,
        itinerary: [{
          day: 1,
          date: dates[0],
          title: 'Day 1 - API Error',
          activities: [{
            time: 'Morning',
            description: 'We\'re having trouble connecting to our travel APIs. Please check your API keys and try again.',
            category: 'Travel' as const,
            address: 'Location pending'
          }]
        }],
        quickTips: [
          'Ensure you have a stable internet connection',
          'Check that your Foursquare and OpenWeatherMap API keys are in your .env file',
          'Try specifying a major city as your destination'
        ]
      };
    }
  }
);
